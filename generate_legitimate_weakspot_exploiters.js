/**
 * Legitimate Weakspot Exploiters Generator
 * Uses REAL baseball intelligence systems instead of fabricated data
 * - BaseballAPI for sophisticated pitcher vs team analysis
 * - Arsenal data for actual pitcher vulnerabilities
 * - Historical matchup performance
 * - Contextual factors and confidence scoring
 */

const fs = require('fs').promises;
const path = require('path');

// Import the BaseballAPI service for real analysis
const baseballAnalysisService = {
  async analyzePitcherVsTeam({
    pitcherName,
    teamAbbr,
    sortBy = 'hr_score',
    ascending = false,
    limit = 15,
    detailed = false,
    includeConfidence = true,
    includeDashboardContext = false,
    date = null
  }) {
    console.log(`üîç Calling BaseballAPI: ${pitcherName} vs ${teamAbbr}`);
    try {
      const response = await fetch('http://localhost:8000/analyze/pitcher-vs-team', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          pitcher_name: pitcherName,
          team: teamAbbr,
          sort_by: sortBy,
          ascending: ascending,
          limit: limit,
          detailed: detailed,
          include_confidence: includeConfidence,
          include_dashboard_context: includeDashboardContext,
          date: date
        })
      });

      if (!response.ok) {
        const errorData = await response.text();
        throw new Error(`BaseballAPI request failed: ${response.status} - ${errorData}`);
      }

      const result = await response.json();
      console.log(`‚úÖ BaseballAPI returned ${result.predictions?.length || 0} predictions`);
      return result;
    } catch (error) {
      // Don't warn for expected 404s - just return null
      if (error.message.includes('404')) {
        console.log(`‚ÑπÔ∏è Pitcher '${pitcherName}' not in BaseballAPI database - skipping`);
      } else {
        console.warn(`BaseballAPI analysis failed for ${pitcherName} vs ${teamAbbr}:`, error.message);
      }
      return null;
    }
  }
};

/**
 * Load pitcher arsenal stats for vulnerability analysis
 */
async function loadPitcherArsenalStats(pitcherName) {
  try {
    const arsenalPath = path.join(__dirname, 'public/data/stats/pitcherpitcharsenalstats_2025.csv');
    const csvContent = await fs.readFile(arsenalPath, 'utf8');
    
    // Parse CSV and find pitcher data
    const lines = csvContent.split('\n');
    const headers = lines[0].split(',');
    const pitcherData = [];
    
    for (let i = 1; i < lines.length; i++) {
      const values = lines[i].split(',');
      if (values.length >= headers.length) {
        const row = {};
        headers.forEach((header, index) => {
          row[header.trim()] = values[index]?.trim();
        });
        
        // Match pitcher name (handle variations)
        if (row.player_name && (
          row.player_name.toLowerCase().includes(pitcherName.toLowerCase()) ||
          pitcherName.toLowerCase().includes(row.player_name.toLowerCase())
        )) {
          pitcherData.push(row);
        }
      }
    }
    
    return pitcherData;
  } catch (error) {
    console.warn(`Could not load arsenal stats for ${pitcherName}:`, error.message);
    return [];
  }
}

/**
 * Analyze real pitcher vulnerabilities from arsenal data
 */
async function extractArsenalWeaknesses(pitcherName) {
  const arsenalData = await loadPitcherArsenalStats(pitcherName);
  
  if (arsenalData.length === 0) {
    return {
      weaknesses: [],
      confidence: 0.3,
      dataQuality: 'limited'
    };
  }
  
  const vulnerabilities = [];
  let totalPitches = 0;
  
  arsenalData.forEach(pitchData => {
    const pitchType = pitchData.pitch_name || 'Unknown';
    const runValue = parseFloat(pitchData.run_value_per_100) || 0;
    const whiffPercent = parseFloat(pitchData.whiff_percent) || 0;
    const hardHitPercent = parseFloat(pitchData.hard_hit_percent) || 0;
    const slugging = parseFloat(pitchData.slg) || 0;
    const usage = parseFloat(pitchData.pitch_usage) || 0;
    
    totalPitches += usage;
    
    // Identify actual weaknesses based on performance metrics
    if (runValue > 1.0) { // Poor run prevention
      vulnerabilities.push({
        pitchType,
        weakness: `${pitchType} allows high run value (${runValue.toFixed(1)})`,
        severity: runValue > 2.0 ? 'high' : 'medium',
        metric: 'run_value',
        value: runValue,
        usage: usage
      });
    }
    
    if (hardHitPercent > 40) { // High hard contact
      vulnerabilities.push({
        pitchType,
        weakness: `${pitchType} generates hard contact (${hardHitPercent.toFixed(1)}%)`,
        severity: hardHitPercent > 50 ? 'high' : 'medium',
        metric: 'hard_contact',
        value: hardHitPercent,
        usage: usage
      });
    }
    
    if (slugging > 0.500) { // High slugging allowed
      vulnerabilities.push({
        pitchType,
        weakness: `${pitchType} allows high slugging (${slugging.toFixed(3)})`,
        severity: slugging > 0.600 ? 'high' : 'medium',
        metric: 'slugging',
        value: slugging,
        usage: usage
      });
    }
    
    if (whiffPercent < 15 && usage > 10) { // Low whiff rate on frequently used pitch
      vulnerabilities.push({
        pitchType,
        weakness: `${pitchType} low swing-and-miss rate (${whiffPercent.toFixed(1)}%)`,
        severity: 'medium',
        metric: 'whiff_rate',
        value: whiffPercent,
        usage: usage
      });
    }
  });
  
  // Sort by severity and usage (more frequently used weaknesses are more exploitable)
  vulnerabilities.sort((a, b) => {
    const severityWeight = { high: 3, medium: 2, low: 1 };
    const aScore = severityWeight[a.severity] * (a.usage / 100);
    const bScore = severityWeight[b.severity] * (b.usage / 100);
    return bScore - aScore;
  });
  
  return {
    weaknesses: vulnerabilities,
    confidence: Math.min(0.9, 0.5 + (totalPitches / 200)), // Higher confidence with more pitch data
    dataQuality: vulnerabilities.length > 0 ? 'good' : 'limited'
  };
}

/**
 * Calculate legitimate exploitability score using real analysis
 */
async function calculateLegitimateExploitabilityScore(batter, pitcherName, pitcherVulnerabilities, gameContext) {
  let exploitIndex = 0;
  let confidence = 0.5;
  const exploitationFactors = [];
  
  try {
    // 1. BaseballAPI Analysis (40% weight)
    // The API expects the team that the pitcher is FACING, not the batter's team
    const opposingTeam = batter.team || batter.Team;
    const apiAnalysis = await baseballAnalysisService.analyzePitcherVsTeam({
      pitcherName, 
      teamAbbr: opposingTeam
    });
    
    if (apiAnalysis && apiAnalysis.predictions) {
      console.log(`   üîç Looking for "${batter.name}" (original) in API predictions:`, apiAnalysis.predictions.map(p => p.player_name || p.batter_name).slice(0, 3));
      
      // Find this specific batter in the predictions
      const batterPrediction = apiAnalysis.predictions.find(p => 
        (p.player_name && (
          p.player_name.toLowerCase().includes(batter.name.toLowerCase()) ||
          batter.name.toLowerCase().includes(p.player_name.toLowerCase())
        )) || 
        (p.batter_name && (
          p.batter_name.toLowerCase().includes(batter.name.toLowerCase()) ||
          batter.name.toLowerCase().includes(p.batter_name.toLowerCase())
        ))
      );
      
      if (batterPrediction) {
        const hrScore = batterPrediction.score || batterPrediction.hr_score || 50;
        exploitIndex += hrScore * 0.40;
        confidence += 0.2; // Real API data boosts confidence
        
        if (hrScore > 75) {
          exploitationFactors.push('High HR probability from BaseballAPI analysis');
        }
        const hitProb = batterPrediction.outcome_probabilities?.hit || batterPrediction.hit_probability || 0;
        if (hitProb > 25) {
          exploitationFactors.push('Strong hit probability prediction');
        }
        
        console.log(`   ‚úÖ Found ${batter.name} in API with HR score: ${hrScore}`);
      } else {
        // Use team average if specific batter not found
        const avgHRScore = apiAnalysis.predictions.reduce((sum, p) => sum + (p.hr_score || 0), 0) / apiAnalysis.predictions.length;
        exploitIndex += avgHRScore * 0.25; // Reduced weight for team average
        exploitationFactors.push('Team-level pitcher analysis (individual data unavailable)');
      }
    } else if (!apiAnalysis) {
      // No BaseballAPI data available - reduce confidence significantly
      confidence *= 0.5;
      exploitIndex += 25; // Minimal base score
    }
    
    // 2. Arsenal Vulnerability Exploitation (30% weight)
    if (pitcherVulnerabilities.weaknesses.length > 0) {
      const primaryWeakness = pitcherVulnerabilities.weaknesses[0];
      let arsenalScore = 0;
      
      // Score based on weakness severity and usage
      const severityScores = { high: 80, medium: 60, low: 40 };
      arsenalScore = severityScores[primaryWeakness.severity] || 50;
      
      // Boost for frequently used vulnerable pitches
      if (primaryWeakness.usage > 20) {
        arsenalScore += 10;
        exploitationFactors.push(`Primary pitch (${primaryWeakness.pitchType}) is vulnerable and frequently used`);
      }
      
      exploitIndex += arsenalScore * 0.30;
      confidence += pitcherVulnerabilities.confidence * 0.1;
      
      exploitationFactors.push(`Pitcher weakness: ${primaryWeakness.weakness}`);
    }
    
    // 3. Batter Performance Analysis (20% weight)
    const avg = parseFloat(batter.AVG) || 0;
    const slg = parseFloat(batter.SLG) || 0;
    const hr = batter.HR || 0;
    const h = batter.H || 0;
    
    let performanceScore = 0;
    performanceScore += avg * 100 * 0.5; // Batting average component
    performanceScore += (slg - 0.400) * 100; // Power component (above league average)
    performanceScore += hr * 8; // HR bonus
    
    if (h >= 2) {
      performanceScore += 15;
      exploitationFactors.push('Recent multi-hit performance');
    }
    if (hr >= 1) {
      performanceScore += 20;
      exploitationFactors.push('Recent power display');
    }
    if (avg > 0.300) {
      exploitationFactors.push('Hot hitting form');
    }
    
    exploitIndex += Math.min(90, performanceScore) * 0.20;
    
    // 4. Contextual Factors (10% weight)
    let contextScore = 50; // Base score
    
    if (gameContext.isHomeTeam) {
      contextScore += 8;
      exploitationFactors.push('Home field advantage');
    }
    
    // Venue factors (simplified for now, could integrate stadium context service)
    if (gameContext.venue && gameContext.venue.toLowerCase().includes('yankee')) {
      contextScore += 10;
      exploitationFactors.push('Hitter-friendly ballpark');
    }
    
    exploitIndex += contextScore * 0.10;
    
    // Ensure reasonable bounds
    exploitIndex = Math.max(30, Math.min(100, exploitIndex));
    confidence = Math.max(0.3, Math.min(0.95, confidence));
    
    // Determine primary weakness from real analysis
    let keyWeakness = 'Standard matchup';
    if (pitcherVulnerabilities.weaknesses.length > 0) {
      keyWeakness = pitcherVulnerabilities.weaknesses[0].weakness;
    } else if (apiAnalysis && apiAnalysis.predictions.length > 0) {
      keyWeakness = 'Pitcher struggles vs this lineup';
    }
    
    return {
      exploitIndex: Math.round(exploitIndex * 10) / 10,
      confidence: Math.round(confidence * 100) / 100,
      keyWeakness,
      exploitationFactors,
      dataQuality: pitcherVulnerabilities.dataQuality
    };
    
  } catch (error) {
    console.error(`Error calculating exploitability for ${batter.name}:`, error);
    
    // Fallback to basic analysis if advanced systems fail
    const basicScore = Math.min(80, (parseFloat(batter.AVG) || 0) * 100 + (batter.HR || 0) * 10);
    return {
      exploitIndex: basicScore,
      confidence: 0.4,
      keyWeakness: 'Limited analysis data available',
      exploitationFactors: ['Basic performance metrics only'],
      dataQuality: 'limited'
    };
  }
}

/**
 * Generate legitimate weakspot exploiters using real baseball intelligence
 */
async function generateLegitimateWeakspotExploiters(targetDate) {
  try {
    console.log(`üéØ Generating LEGITIMATE weakspot exploiters for ${targetDate}...`);
    
    // Check if BaseballAPI is available
    try {
      const healthCheck = await fetch('http://localhost:8000/health');
      if (!healthCheck.ok) {
        throw new Error('BaseballAPI not available');
      }
      console.log(`üîó BaseballAPI connected successfully`);
    } catch (error) {
      console.warn(`‚ö†Ô∏è BaseballAPI not available - using limited analysis: ${error.message}`);
    }
    
    // 1. Load starting lineups data for real pitcher matchups
    const lineupsPath = path.join(__dirname, `public/data/lineups/starting_lineups_${targetDate}.json`);
    const lineupsData = JSON.parse(await fs.readFile(lineupsPath, 'utf8'));
    console.log(`üìä Loaded starting lineups: ${lineupsData.games.length} games`);
    
    // 2. Load roster data for name mapping
    const rosterPath = path.join(__dirname, 'public/data/rosters.json');
    const rosterData = JSON.parse(await fs.readFile(rosterPath, 'utf8'));
    
    // 3. Load player performance data
    let gameData = null;
    for (let daysBack = 0; daysBack <= 3; daysBack++) {
      const checkDate = new Date(targetDate);
      checkDate.setDate(checkDate.getDate() - daysBack);
      const actualDate = checkDate.toISOString().split('T')[0];
      
      const year = checkDate.getFullYear();
      const month = checkDate.toLocaleDateString('en-US', { month: 'long' }).toLowerCase();
      const day = String(checkDate.getDate()).padStart(2, '0');
      
      const gamePath = path.join(__dirname, `public/data/${year}/${month}/${month}_${day}_${year}.json`);
      
      try {
        const gameFile = await fs.readFile(gamePath, 'utf8');
        const data = JSON.parse(gameFile);
        
        if (data.players && data.players.length > 0) {
          gameData = data;
          console.log(`üìÖ Using player performance data from ${actualDate} (${data.players.length} players)`);
          break;
        }
      } catch (error) {
        console.log(`üìÖ No performance data for ${actualDate}, checking previous day...`);
      }
    }
    
    if (!gameData || !gameData.players) {
      throw new Error('No player performance data found');
    }
    
    // 4. Generate legitimate exploiter opportunities
    const exploiters = [];
    
    console.log(`üîç Analyzing real pitcher vulnerabilities...`);
    
    for (const game of lineupsData.games.slice(0, 5)) { // Limit to first 5 games for verified pitchers
      const homeTeam = game.teams.home.abbr;
      const awayTeam = game.teams.away.abbr;
      const homePitcher = game.pitchers.home.name;
      const awayPitcher = game.pitchers.away.name;
      const venue = game.venue.name;
      
      if (!homePitcher || !awayPitcher) continue;
      
      console.log(`üèüÔ∏è Analyzing ${awayTeam}@${homeTeam}: ${awayPitcher} vs ${homePitcher}`);
      
      // Analyze pitcher vulnerabilities using real data
      const homePitcherVulns = await extractArsenalWeaknesses(homePitcher);
      const awayPitcherVulns = await extractArsenalWeaknesses(awayPitcher);
      
      // Find hitters from recent performance data
      const homeHitters = gameData.players.filter(p => 
        p.playerType === 'hitter' && 
        (p.team === homeTeam || p.Team === homeTeam) &&
        (p.AB > 0 || p.H > 0) &&
        p.name
      ).slice(0, 4); // Top 4 hitters per team
      
      const awayHitters = gameData.players.filter(p => 
        p.playerType === 'hitter' && 
        (p.team === awayTeam || p.Team === awayTeam) &&
        (p.AB > 0 || p.H > 0) &&
        p.name
      ).slice(0, 4);
      
      // Analyze away hitters vs home pitcher
      for (const hitter of awayHitters) {
        try {
          const fullName = rosterData.find(r => 
            r.team === awayTeam && (
              r.name === hitter.name || 
              (r.fullName && r.fullName.includes(hitter.name.split(' ')[1])) ||
              hitter.name.includes(r.name.split(' ')[1] || '')
            )
          )?.fullName || hitter.name;
          
          // Use full name for analysis
          const hitterWithFullName = { ...hitter, name: fullName };
          
          const analysis = await calculateLegitimateExploitabilityScore(
            hitterWithFullName, 
            homePitcher, 
            homePitcherVulns,
            { venue, isHomeTeam: false }
          );
          
          // Include if we have reasonable score and some confidence
          console.log(`   üíØ ${fullName} vs ${homePitcher}: Score=${analysis.exploitIndex.toFixed(1)}, Confidence=${analysis.confidence.toFixed(2)}, Quality=${analysis.dataQuality}`);
          
          if (analysis.exploitIndex >= 50 && analysis.confidence >= 0.3) {
            exploiters.push({
              player: fullName,
              team: awayTeam,
              pitcher: homePitcher,
              exploitIndex: analysis.exploitIndex,
              confidence: analysis.confidence,
              keyWeakness: analysis.keyWeakness,
              categories: analysis.exploitationFactors.length > 0 ? 
                         analysis.exploitationFactors.slice(0, 2) : ['Standard Analysis'],
              venue: venue,
              isHomeTeam: false,
              stadium: { parkFactor: 1.0 },
              playerData: {
                AB: hitter.AB || 0,
                H: hitter.H || 0,
                HR: hitter.HR || 0,
                RBI: hitter.RBI || 0
              },
              analysisQuality: analysis.dataQuality,
              factors: analysis.exploitationFactors
            });
          }
        } catch (error) {
          console.warn(`‚ö†Ô∏è Analysis failed for ${hitter.name}:`, error.message);
        }
      }
      
      // Analyze home hitters vs away pitcher
      for (const hitter of homeHitters) {
        try {
          const fullName = rosterData.find(r => 
            r.team === homeTeam && (
              r.name === hitter.name || 
              (r.fullName && r.fullName.includes(hitter.name.split(' ')[1])) ||
              hitter.name.includes(r.name.split(' ')[1] || '')
            )
          )?.fullName || hitter.name;
          
          // Use full name for analysis
          const hitterWithFullName = { ...hitter, name: fullName };
          
          const analysis = await calculateLegitimateExploitabilityScore(
            hitterWithFullName, 
            awayPitcher, 
            awayPitcherVulns,
            { venue, isHomeTeam: true }
          );
          
          // Include if we have reasonable score and some confidence
          console.log(`   üíØ ${fullName} vs ${homePitcher}: Score=${analysis.exploitIndex.toFixed(1)}, Confidence=${analysis.confidence.toFixed(2)}, Quality=${analysis.dataQuality}`);
          
          if (analysis.exploitIndex >= 50 && analysis.confidence >= 0.3) {
            exploiters.push({
              player: fullName,
              team: homeTeam,
              pitcher: awayPitcher,
              exploitIndex: analysis.exploitIndex,
              confidence: analysis.confidence,
              keyWeakness: analysis.keyWeakness,
              categories: analysis.exploitationFactors.length > 0 ? 
                         analysis.exploitationFactors.slice(0, 2) : ['Standard Analysis'],
              venue: venue,
              isHomeTeam: true,
              stadium: { parkFactor: 1.0 },
              playerData: {
                AB: hitter.AB || 0,
                H: hitter.H || 0,
                HR: hitter.HR || 0,
                RBI: hitter.RBI || 0
              },
              analysisQuality: analysis.dataQuality,
              factors: analysis.exploitationFactors
            });
          }
        } catch (error) {
          console.warn(`‚ö†Ô∏è Analysis failed for ${hitter.name}:`, error.message);
        }
      }
    }
    
    // Sort by legitimate exploit index and confidence
    exploiters.sort((a, b) => {
      const aScore = a.exploitIndex * a.confidence;
      const bScore = b.exploitIndex * b.confidence;
      return bScore - aScore;
    });
    
    // Take top 15 highest-quality opportunities
    const topExploiters = exploiters.slice(0, 15);
    
    const result = {
      generated: new Date().toISOString(),
      date: targetDate,
      analysisType: "legitimate_baseball_intelligence",
      dataQuality: "real_pitcher_vulnerabilities",
      exploiters: topExploiters
    };
    
    console.log(`üéØ Generated ${topExploiters.length} LEGITIMATE weakspot exploiters`);
    if (topExploiters.length > 0) {
      console.log(`üèÜ Top exploiter: ${topExploiters[0].player} vs ${topExploiters[0].pitcher} (${topExploiters[0].exploitIndex})`);
      console.log(`üîç Key weakness: ${topExploiters[0].keyWeakness}`);
    }
    
    return result;
    
  } catch (error) {
    console.error('‚ùå Error generating legitimate weakspot exploiters:', error);
    throw error;
  }
}

// Main execution
async function main() {
  try {
    const targetDate = process.argv[2] || '2025-07-28';
    const result = await generateLegitimateWeakspotExploiters(targetDate);
    
    // Write to output files
    const outputDir = path.join(__dirname, 'public/data/weakspot_exploiters');
    await fs.mkdir(outputDir, { recursive: true });
    
    const dateSpecificPath = path.join(outputDir, `weakspot_exploiters_${targetDate}.json`);
    const latestPath = path.join(outputDir, 'weakspot_exploiters_latest.json');
    
    await fs.writeFile(dateSpecificPath, JSON.stringify(result, null, 2));
    await fs.writeFile(latestPath, JSON.stringify(result, null, 2));
    
    console.log(`‚úÖ LEGITIMATE weakspot exploiters data written to:`);
    console.log(`   üìÑ ${dateSpecificPath}`);
    console.log(`   üìÑ ${latestPath}`);
    
  } catch (error) {
    console.error('‚ùå Failed to generate legitimate weakspot exploiters:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = { generateLegitimateWeakspotExploiters };
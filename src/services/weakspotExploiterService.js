/**
 * Weakspot Exploiter Service
 * Identifies highest-value hitters who specifically exploit opposing pitcher weaknesses
 * Integrates daily lineup data with pitcher arsenal analysis for actionable insights
 */

import { fetchPlayerData, fetchGameData } from './dataService.js';
import advancedPitcherIntelligence from './advancedPitcherIntelligence.js';
import baseballAnalysisService from './baseballAnalysisService.js';
import stadiumContextService from './stadiumContextService.js';
import weatherContextService from './weatherContextService.js';

class WeakspotExploiterService {
  constructor() {
    this.cache = new Map();
    this.cacheTimeout = 15 * 60 * 1000; // 15 minutes cache
    this.confirmedLineupsCache = new Map();
    this.pitcherAssignmentsCache = new Map();
  }

  /**
   * Generate daily exploiter rankings for confirmed lineups
   */
  async generateDailyExploiters(currentDate) {
    const cacheKey = `daily_exploiters_${currentDate}`;
    
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      if (Date.now() - cached.timestamp < this.cacheTimeout) {
        return cached.data;
      }
    }

    try {
      console.log(`ðŸŽ¯ WEAKSPOT EXPLOITERS: Generating analysis for ${currentDate}`);
      
      // 1. Load today's games and lineups
      const gameData = await this.loadTodaysGames(currentDate);
      if (!gameData || gameData.length === 0) {
        return this.getEmptyExploitersResult('No games scheduled for this date');
      }

      // 2. Extract confirmed lineups and pitcher assignments
      const { confirmedLineups, pitcherAssignments } = await this.extractLineupsAndPitchers(gameData, currentDate);
      
      // 3. Analyze pitcher vulnerabilities
      const pitcherWeakspots = await this.analyzePitcherVulnerabilities(pitcherAssignments);
      
      // 4. Score lineup exploitability
      const exploiters = await this.scoreLineupExploiters(confirmedLineups, pitcherWeakspots, pitcherAssignments);
      
      // 5. Enhanced context (ballpark, weather, recent form)
      const enhancedExploiters = await this.enhanceWithContext(exploiters, gameData);
      
      // 6. Filter and rank final results
      const rankedExploiters = this.rankAndFilterExploiters(enhancedExploiters);

      const result = {
        date: currentDate,
        exploiters: rankedExploiters,
        totalAnalyzed: exploiters.length,
        gamesAnalyzed: gameData.length,
        confidence: this.calculateOverallConfidence(rankedExploiters),
        lastUpdated: new Date().toISOString()
      };

      this.cache.set(cacheKey, {
        data: result,
        timestamp: Date.now()
      });

      console.log(`ðŸŽ¯ WEAKSPOT EXPLOITERS: Generated ${rankedExploiters.length} exploiter opportunities`);
      return result;

    } catch (error) {
      console.error('Error generating daily exploiters:', error);
      return this.getEmptyExploitersResult(`Analysis failed: ${error.message}`);
    }
  }

  /**
   * Load today's scheduled games
   */
  async loadTodaysGames(currentDate) {
    try {
      const gameData = await fetchGameData(currentDate);
      return gameData?.games || [];
    } catch (error) {
      console.warn(`Failed to load games for ${currentDate}:`, error);
      return [];
    }
  }

  /**
   * Extract confirmed lineups and pitcher assignments from game data
   */
  async extractLineupsAndPitchers(games, currentDate) {
    const confirmedLineups = {};
    const pitcherAssignments = {};

    try {
      // Load player stats to get roster information
      const playerData = await fetchPlayerData(currentDate);
      
      for (const game of games) {
        const { homeTeam, awayTeam } = game;
        
        // Extract lineups from player data (players who played that day)
        const homeLineup = playerData.filter(p => 
          (p.team === homeTeam || p.Team === homeTeam) && 
          (p.AB > 0 || p.H > 0 || p.PA > 0)
        ).slice(0, 9); // Top 9 lineup spots
        
        const awayLineup = playerData.filter(p => 
          (p.team === awayTeam || p.Team === awayTeam) && 
          (p.AB > 0 || p.H > 0 || p.PA > 0)
        ).slice(0, 9);

        if (homeLineup.length >= 7) { // Minimum lineup threshold
          confirmedLineups[homeTeam] = homeLineup;
        }
        
        if (awayLineup.length >= 7) {
          confirmedLineups[awayTeam] = awayLineup;
        }

        // Extract pitcher assignments
        const homePitcher = playerData.find(p => 
          (p.team === homeTeam || p.Team === homeTeam) && 
          (p.GS === 1 || p.IP > 3) // Starting pitcher indicators
        );
        
        const awayPitcher = playerData.find(p => 
          (p.team === awayTeam || p.Team === awayTeam) && 
          (p.GS === 1 || p.IP > 3)
        );

        if (homePitcher) {
          pitcherAssignments[homeTeam] = {
            pitcher: homePitcher,
            opposingTeam: awayTeam,
            venue: game.venue || 'Unknown'
          };
        }
        
        if (awayPitcher) {
          pitcherAssignments[awayTeam] = {
            pitcher: awayPitcher,
            opposingTeam: homeTeam,
            venue: game.venue || 'Unknown'
          };
        }
      }

      console.log(`ðŸŽ¯ LINEUPS EXTRACTED: ${Object.keys(confirmedLineups).length} teams with confirmed lineups`);
      console.log(`ðŸŽ¯ PITCHERS EXTRACTED: ${Object.keys(pitcherAssignments).length} pitcher assignments`);

      return { confirmedLineups, pitcherAssignments };

    } catch (error) {
      console.error('Error extracting lineups and pitchers:', error);
      return { confirmedLineups: {}, pitcherAssignments: {} };
    }
  }

  /**
   * Analyze pitcher vulnerabilities using advanced pitcher intelligence
   */
  async analyzePitcherVulnerabilities(pitcherAssignments) {
    const pitcherWeakspots = {};

    for (const [team, assignment] of Object.entries(pitcherAssignments)) {
      try {
        const { pitcher, opposingTeam } = assignment;
        
        // Use BaseballAPI for comprehensive pitcher analysis
        const apiAnalysis = await this.getPitcherAnalysisFromAPI(pitcher, opposingTeam);
        
        if (apiAnalysis && apiAnalysis.predictions) {
          // Extract pitcher vulnerabilities from API response
          const vulnerabilities = this.extractPitcherVulnerabilities(apiAnalysis, pitcher);
          
          pitcherWeakspots[pitcher.name || pitcher.fullName] = {
            pitcher: pitcher,
            team: team,
            opposingTeam: opposingTeam,
            vulnerabilities: vulnerabilities,
            threatLevel: this.calculateThreatLevel(vulnerabilities),
            confidence: apiAnalysis.confidence || 0.7
          };
        } else {
          // Fallback to basic analysis
          pitcherWeakspots[pitcher.name || pitcher.fullName] = {
            pitcher: pitcher,
            team: team,
            opposingTeam: opposingTeam,
            vulnerabilities: this.getBasicVulnerabilities(pitcher),
            threatLevel: 'medium',
            confidence: 0.4
          };
        }

      } catch (error) {
        console.warn(`Failed to analyze pitcher ${assignment.pitcher.name}:`, error);
      }
    }

    return pitcherWeakspots;
  }

  /**
   * Get pitcher analysis from BaseballAPI
   */
  async getPitcherAnalysisFromAPI(pitcher, opposingTeam) {
    try {
      const pitcherName = pitcher.name || pitcher.fullName || pitcher.playerName;
      
      const analysis = await baseballAnalysisService.analyzePitcherVsTeam(
        pitcherName,
        opposingTeam,
        { 
          includeConfidence: true,
          maxResults: 15,
          sortBy: 'score'
        }
      );

      return analysis;
    } catch (error) {
      console.warn(`BaseballAPI analysis failed for ${pitcher.name}:`, error);
      return null;
    }
  }

  /**
   * Extract pitcher vulnerabilities from API analysis
   */
  extractPitcherVulnerabilities(apiAnalysis, pitcher) {
    const vulnerabilities = {
      weakPitches: [],
      highThreatBatters: [],
      averageHRScore: 0,
      vulnerabilityIndex: 0
    };

    if (apiAnalysis.predictions && apiAnalysis.predictions.length > 0) {
      const predictions = apiAnalysis.predictions;
      
      // Calculate average HR score (pitcher vulnerability indicator)
      const totalHRScore = predictions.reduce((sum, p) => sum + (p.hr_score || 0), 0);
      vulnerabilities.averageHRScore = totalHRScore / predictions.length;
      
      // Identify high threat batters (HR score > 70)
      vulnerabilities.highThreatBatters = predictions
        .filter(p => (p.hr_score || 0) > 70)
        .map(p => ({
          player: p.player_name,
          hrScore: p.hr_score,
          keyWeakness: this.identifyKeyWeakness(p)
        }));

      // Extract vulnerable pitch types from arsenal analysis
      vulnerabilities.weakPitches = this.extractWeakPitchTypes(predictions);
      
      // Calculate overall vulnerability index
      vulnerabilities.vulnerabilityIndex = this.calculateVulnerabilityIndex(
        vulnerabilities.averageHRScore,
        vulnerabilities.highThreatBatters.length,
        predictions.length
      );
    }

    return vulnerabilities;
  }

  /**
   * Score lineup exploitability against pitcher weaknesses
   */
  async scoreLineupExploiters(confirmedLineups, pitcherWeakspots, pitcherAssignments) {
    const exploiters = [];

    for (const [team, lineup] of Object.entries(confirmedLineups)) {
      try {
        // Find opposing pitcher
        const opposingPitcherAssignment = Object.values(pitcherAssignments)
          .find(assignment => assignment.opposingTeam === team);
        
        if (!opposingPitcherAssignment) {
          console.warn(`No opposing pitcher found for team ${team}`);
          continue;
        }

        const opposingPitcher = opposingPitcherAssignment.pitcher;
        const pitcherName = opposingPitcher.name || opposingPitcher.fullName;
        const pitcherWeakness = pitcherWeakspots[pitcherName];

        if (!pitcherWeakness) {
          console.warn(`No pitcher weakness data for ${pitcherName}`);
          continue;
        }

        // Score each batter in the lineup
        for (const batter of lineup) {
          const exploitabilityScore = await this.calculateExploitabilityScore(
            batter,
            pitcherWeakness,
            opposingPitcherAssignment
          );

          if (exploitabilityScore.exploitIndex >= 65) { // Minimum threshold
            exploiters.push({
              player: batter.name || batter.fullName || batter.playerName,
              playerData: batter,
              team: team,
              pitcher: pitcherName,
              pitcherData: opposingPitcher,
              exploitIndex: exploitabilityScore.exploitIndex,
              keyWeakness: exploitabilityScore.keyWeakness,
              confidence: exploitabilityScore.confidence,
              categories: exploitabilityScore.categories,
              venue: opposingPitcherAssignment.venue
            });
          }
        }

      } catch (error) {
        console.error(`Error scoring lineup for team ${team}:`, error);
      }
    }

    return exploiters.sort((a, b) => b.exploitIndex - a.exploitIndex);
  }

  /**
   * Calculate exploitability score for batter vs pitcher weakness
   */
  async calculateExploitabilityScore(batter, pitcherWeakness, pitcherAssignment) {
    try {
      const batterName = batter.name || batter.fullName || batter.playerName;
      
      // Base exploitability components
      let exploitIndex = 0;
      let confidence = 0.5;
      const categories = [];
      let keyWeakness = 'General matchup';

      // 1. Batter vs Pitcher Weakness Analysis (40% weight)
      const arsenalMatchup = this.analyzeBatterVsWeakPitches(batter, pitcherWeakness);
      exploitIndex += arsenalMatchup.score * 0.40;
      confidence = Math.max(confidence, arsenalMatchup.confidence);
      if (arsenalMatchup.keyWeakness) {
        keyWeakness = arsenalMatchup.keyWeakness;
      }

      // 2. Pitcher Vulnerability Level (25% weight)
      const pitcherVulnScore = Math.min(100, pitcherWeakness.vulnerabilities.vulnerabilityIndex);
      exploitIndex += pitcherVulnScore * 0.25;

      // 3. Batter Recent Form (15% weight)
      const recentForm = this.assessBatterRecentForm(batter);
      exploitIndex += recentForm.score * 0.15;
      if (recentForm.isHot) categories.push('Hot Form');

      // 4. Handedness Advantage (10% weight)
      const handednessAdvantage = this.calculateHandednessAdvantage(batter, pitcherWeakness.pitcher);
      exploitIndex += handednessAdvantage * 0.10;
      if (handednessAdvantage > 60) categories.push('Handedness Edge');

      // 5. Power vs Contact Classification (10% weight)
      const batterType = this.classifyBatterType(batter);
      if (batterType.isPowerThreat && pitcherWeakness.vulnerabilities.averageHRScore > 70) {
        exploitIndex += 80 * 0.10;
        categories.push('Power vs Vulnerable Pitcher');
      } else if (batterType.isContactHitter && pitcherWeakness.threatLevel === 'high') {
        exploitIndex += 70 * 0.10;
        categories.push('Contact vs Hittable Pitcher');
      } else {
        exploitIndex += 50 * 0.10;
      }

      return {
        exploitIndex: Math.min(100, Math.max(0, exploitIndex)),
        keyWeakness,
        confidence,
        categories
      };

    } catch (error) {
      console.error(`Error calculating exploitability for ${batter.name}:`, error);
      return {
        exploitIndex: 50,
        keyWeakness: 'Analysis error',
        confidence: 0.3,
        categories: ['Limited Data']
      };
    }
  }

  /**
   * Analyze how well batter hits pitcher's weak pitch types
   */
  analyzeBatterVsWeakPitches(batter, pitcherWeakness) {
    // This would integrate with the pitcher arsenal analysis
    // For now, use basic metrics as foundation
    
    const batterPower = (batter.HR || 0) + (batter.XBH || 0) * 0.5;
    const batterContact = (batter.H || 0) / Math.max(1, batter.AB || 1);
    const pitcherVulnerability = pitcherWeakness.vulnerabilities.averageHRScore || 50;

    const matchupScore = (batterPower * 2 + batterContact * 100) * (pitcherVulnerability / 100);
    
    let keyWeakness = 'Standard matchup';
    if (pitcherWeakness.vulnerabilities.weakPitches.length > 0) {
      keyWeakness = `vs ${pitcherWeakness.vulnerabilities.weakPitches[0]}`;
    }

    return {
      score: Math.min(100, matchupScore),
      confidence: pitcherWeakness.confidence || 0.5,
      keyWeakness
    };
  }

  /**
   * Assess batter's recent form
   */
  assessBatterRecentForm(batter) {
    const recentHits = batter.H || 0;
    const recentAB = batter.AB || 1;
    const recentAvg = recentHits / recentAB;
    
    const isHot = recentAvg > 0.300 || (batter.HR || 0) >= 2;
    const formScore = isHot ? 85 : recentAvg > 0.250 ? 65 : 45;

    return {
      score: formScore,
      isHot,
      average: recentAvg
    };
  }

  /**
   * Calculate handedness advantage
   */
  calculateHandednessAdvantage(batter, pitcher) {
    // Simplified handedness logic
    const batterHand = batter.bats || 'R';
    const pitcherHand = pitcher.throws || 'R';
    
    // Opposite handedness generally favors batter
    if ((batterHand === 'L' && pitcherHand === 'R') || 
        (batterHand === 'R' && pitcherHand === 'L')) {
      return 75; // Favorable matchup
    } else if (batterHand === 'S') {
      return 60; // Switch hitter advantage
    } else {
      return 45; // Same handedness (pitcher advantage)
    }
  }

  /**
   * Classify batter type for strategic matching
   */
  classifyBatterType(batter) {
    const hrRate = (batter.HR || 0) / Math.max(1, batter.G || 1);
    const contactRate = (batter.H || 0) / Math.max(1, batter.AB || 1);
    
    return {
      isPowerThreat: hrRate > 0.15 || (batter.HR || 0) >= 15,
      isContactHitter: contactRate > 0.280 && hrRate < 0.12,
      isBalanced: hrRate >= 0.12 && contactRate >= 0.260
    };
  }

  /**
   * Enhance exploiters with contextual data
   */
  async enhanceWithContext(exploiters, gameData) {
    const enhanced = [];

    for (const exploiter of exploiters) {
      try {
        const gameContext = gameData.find(g => 
          g.homeTeam === exploiter.team || g.awayTeam === exploiter.team
        );

        // Add stadium context
        let stadiumContext = null;
        if (gameContext?.venue) {
          try {
            stadiumContext = await stadiumContextService.getStadiumContext(gameContext.venue);
          } catch (error) {
            console.warn(`Failed to get stadium context for ${gameContext.venue}`);
          }
        }

        // Add weather context (placeholder for now)
        const weatherContext = {
          impact: 'neutral',
          description: 'Standard conditions'
        };

        enhanced.push({
          ...exploiter,
          stadium: stadiumContext,
          weather: weatherContext,
          gameTime: gameContext?.dateTime,
          isHomeTeam: gameContext?.homeTeam === exploiter.team
        });

      } catch (error) {
        console.warn(`Failed to enhance context for ${exploiter.player}`);
        enhanced.push(exploiter);
      }
    }

    return enhanced;
  }

  /**
   * Rank and filter final exploiter results
   */
  rankAndFilterExploiters(exploiters) {
    return exploiters
      .filter(e => e.exploitIndex >= 65) // Minimum quality threshold
      .sort((a, b) => {
        // Primary sort: exploit index
        if (Math.abs(a.exploitIndex - b.exploitIndex) > 2) {
          return b.exploitIndex - a.exploitIndex;
        }
        // Secondary sort: confidence
        return b.confidence - a.confidence;
      })
      .slice(0, 20); // Top 20 exploiters
  }

  // Helper methods
  calculateThreatLevel(vulnerabilities) {
    const avgScore = vulnerabilities.averageHRScore || 0;
    const threatCount = vulnerabilities.highThreatBatters?.length || 0;
    
    if (avgScore > 80 || threatCount >= 4) return 'high';
    if (avgScore > 65 || threatCount >= 2) return 'medium';
    return 'low';
  }

  calculateVulnerabilityIndex(avgHRScore, threatCount, totalBatters) {
    const baseVulnerability = avgHRScore;
    const threatMultiplier = (threatCount / Math.max(1, totalBatters)) * 100;
    return Math.min(100, baseVulnerability + threatMultiplier);
  }

  identifyKeyWeakness(prediction) {
    // Extract key weakness from prediction details
    if (prediction.arsenal_matchup > 70) {
      return 'Arsenal vulnerable';
    } else if (prediction.recent_avg > 0.300) {
      return 'Recent hot streak';
    } else if (prediction.hr_probability > 8) {
      return 'HR threat';
    }
    return 'Solid matchup';
  }

  extractWeakPitchTypes(predictions) {
    // Extract weak pitch types from arsenal analysis
    // This would need deeper integration with arsenal data
    return ['Fastball', 'Slider']; // Placeholder
  }

  getBasicVulnerabilities(pitcher) {
    return {
      weakPitches: ['Unknown'],
      highThreatBatters: [],
      averageHRScore: 55,
      vulnerabilityIndex: 55
    };
  }

  calculateOverallConfidence(exploiters) {
    if (exploiters.length === 0) return 0;
    
    const avgConfidence = exploiters.reduce((sum, e) => sum + e.confidence, 0) / exploiters.length;
    return Math.round(avgConfidence * 100);
  }

  getEmptyExploitersResult(reason) {
    return {
      exploiters: [],
      totalAnalyzed: 0,
      gamesAnalyzed: 0,
      confidence: 0,
      error: reason,
      lastUpdated: new Date().toISOString()
    };
  }
}

const weakspotExploiterService = new WeakspotExploiterService();
export default weakspotExploiterService;
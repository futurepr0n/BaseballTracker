/**
 * Enhanced Weakspot Exploiter Service (Professional Grade v2.0)
 * Comprehensive vulnerability analysis using all available CSV data
 * 
 * Features:
 * - Expected statistics regression analysis (xBA_diff, xSLG_diff, wOBA_diff)
 * - Advanced contact quality scoring with barrel rates and sweet spot percentages
 * - 16-scenario handedness analysis integration
 * - Arsenal-specific vulnerability matching
 * - Multi-tier scoring system with dynamic thresholds
 * - Generates 15-20+ sophisticated exploiters
 */

import Papa from 'papaparse';

class EnhancedWeakspotExploiterService {
  constructor() {
    this.cache = new Map();
    this.cacheTimeout = 30 * 60 * 1000; // 30 minutes cache
    
    // Professional data containers
    this.hitterExitVelocity = new Map();
    this.pitcherExitVelocity = new Map();
    this.customBatters = new Map();
    this.customPitchers = new Map();
    this.pitcherArsenal = new Map();
    this.handednessData = new Map();
    this.swingPathData = new Map();
    this.batTrackingData = new Map();
    
    // Analysis containers
    this.recentPerformance = new Map();
    this.platoonSplits = new Map();
    this.parkFactors = new Map();
    
    this.dataLoaded = false;
    this.loadPromise = null;
  }

  /**
   * Main entry point - Generate comprehensive weakspot exploiters
   */
  async generateEnhancedExploiters(currentDate) {
    const cacheKey = `enhanced_exploiters_${currentDate}`;
    
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      if (Date.now() - cached.timestamp < this.cacheTimeout) {
        return cached.data;
      }
    }

    try {
      console.log(`🎯 ENHANCED WEAKSPOT ANALYSIS: Starting comprehensive analysis for ${currentDate}`);
      
      // Ensure all CSV data is loaded
      await this.ensureDataLoaded();
      
      // Load today's lineups
      const lineupData = await this.loadStartingLineups(currentDate);
      if (!lineupData || !lineupData.games || lineupData.games.length === 0) {
        return this.getEmptyResult('No starting lineups available');
      }

      // Generate comprehensive exploiters using all data
      const exploiters = await this.generateComprehensiveExploiters(lineupData.games, currentDate);
      
      // Enhanced filtering and ranking
      const rankedExploiters = this.rankExploitersWithAdvancedScoring(exploiters);
      
      const result = {
        date: currentDate,
        exploiters: rankedExploiters,
        totalAnalyzed: exploiters.length,
        gamesAnalyzed: lineupData.games.length,
        dataQuality: 'professional_grade',
        analysisType: 'comprehensive_weakspot_exploitation',
        dataSourcesUsed: this.getDataSourcesSummary(),
        qualityMetrics: this.calculateQualityMetrics(rankedExploiters),
        lastUpdated: new Date().toISOString()
      };

      this.cache.set(cacheKey, {
        data: result,
        timestamp: Date.now()
      });

      console.log(`🎯 ENHANCED ANALYSIS COMPLETE: ${rankedExploiters.length} high-grade exploiters identified`);
      return result;

    } catch (error) {
      console.error('Enhanced weakspot analysis failed:', error);
      return this.getEmptyResult(`Analysis failed: ${error.message}`);
    }
  }

  /**
   * Ensure all CSV data is loaded
   */
  async ensureDataLoaded() {
    if (this.dataLoaded) return;
    
    if (this.loadPromise) {
      await this.loadPromise;
      return;
    }

    this.loadPromise = this.loadAllCSVData();
    await this.loadPromise;
    this.dataLoaded = true;
  }

  /**
   * Load all CSV data sources
   */
  async loadAllCSVData() {
    console.log('📊 Loading comprehensive baseball analytics data...');
    
    const loadPromises = [
      this.loadHitterExitVelocityData(),
      this.loadPitcherExitVelocityData(),
      this.loadCustomBatterData(),
      this.loadCustomPitcherData(),
      this.loadPitcherArsenalData(),
      this.loadHandednessData(),
      this.loadSwingPathData(),
      this.loadBatTrackingData()
    ];

    await Promise.allSettled(loadPromises);
    
    const totalDataPoints = this.hitterExitVelocity.size + this.pitcherExitVelocity.size + 
                           this.customBatters.size + this.customPitchers.size;
    
    console.log(`✅ Data loading complete: ${totalDataPoints} total data points from 8 sources`);
  }

  /**
   * Load hitter exit velocity data with barrel rates
   */
  async loadHitterExitVelocityData() {
    try {
      const response = await fetch('/data/stats/hitter_exit_velocity_2025.csv');
      const csvText = await response.text();
      
      return new Promise((resolve) => {
        Papa.parse(csvText, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            let count = 0;
            results.data.forEach(row => {
              const playerName = this.normalizeName(row['last_name, first_name']);
              if (playerName) {
                this.hitterExitVelocity.set(playerName, {
                  attempts: parseInt(row.attempts) || 0,
                  realBarrelRate: parseFloat(row.brl_percent) || 0,
                  barrelCount: parseInt(row.barrels) || 0,
                  barrelPA: parseFloat(row.brl_pa) || 0,
                  avgHitSpeed: parseFloat(row.avg_hit_speed) || 0,
                  maxHitSpeed: parseFloat(row.max_hit_speed) || 0,
                  ev50: parseFloat(row.ev50) || 0,
                  ev95Plus: parseInt(row.ev95plus) || 0,
                  ev95Percent: parseFloat(row.ev95percent) || 0,
                  sweetSpotPercent: parseFloat(row.anglesweetspotpercent) || 0,
                  avgHitAngle: parseFloat(row.avg_hit_angle) || 0,
                  maxDistance: parseInt(row.max_distance) || 0,
                  avgDistance: parseInt(row.avg_distance) || 0,
                  avgHRDistance: parseInt(row.avg_hr_distance) || 0,
                  flyballLineDriveRate: parseFloat(row.fbld) || 0,
                  groundballRate: parseFloat(row.gb) || 0,
                  playerId: row.player_id || '',
                  dataQuality: this.assessDataQuality(parseInt(row.attempts) || 0, 'hitter')
                });
                count++;
              }
            });
            console.log(`   📊 Loaded exit velocity data for ${count} hitters`);
            resolve();
          }
        });
      });
    } catch (error) {
      console.warn('Failed to load hitter exit velocity data:', error);
    }
  }

  /**
   * Load pitcher exit velocity data (contact quality allowed)
   */
  async loadPitcherExitVelocityData() {
    try {
      const response = await fetch('/data/stats/pitcher_exit_velocity_2025.csv');
      const csvText = await response.text();
      
      return new Promise((resolve) => {
        Papa.parse(csvText, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            let count = 0;
            results.data.forEach(row => {
              const playerName = this.normalizeName(row['last_name, first_name']);
              if (playerName) {
                this.pitcherExitVelocity.set(playerName, {
                  attempts: parseInt(row.attempts) || 0,
                  realBarrelRateAllowed: parseFloat(row.brl_percent) || 0,
                  barrelsAllowed: parseInt(row.barrels) || 0,
                  barrelPAAllowed: parseFloat(row.brl_pa) || 0,
                  avgHitSpeedAllowed: parseFloat(row.avg_hit_speed) || 0,
                  maxHitSpeedAllowed: parseFloat(row.max_hit_speed) || 0,
                  hardHitPercentAllowed: parseFloat(row.hard_hit_percent) || 0,
                  ev50Allowed: parseFloat(row.ev50) || 0,
                  ev95PlusAllowed: parseInt(row.ev95plus) || 0,
                  ev95PercentAllowed: parseFloat(row.ev95percent) || 0,
                  sweetSpotPercentAllowed: parseFloat(row.anglesweetspotpercent) || 0,
                  avgHitAngleAllowed: parseFloat(row.avg_hit_angle) || 0,
                  maxDistanceAllowed: parseInt(row.max_distance) || 0,
                  avgDistanceAllowed: parseInt(row.avg_distance) || 0,
                  avgHRDistanceAllowed: parseInt(row.avg_hr_distance) || 0,
                  flyballLineDriveRateAllowed: parseFloat(row.fbld) || 0,
                  groundballRateAllowed: parseFloat(row.gb) || 0,
                  playerId: row.player_id || '',
                  dataQuality: this.assessDataQuality(parseInt(row.attempts) || 0, 'pitcher')
                });
                count++;
              }
            });
            console.log(`   ⚾ Loaded exit velocity data for ${count} pitchers`);
            resolve();
          }
        });
      });
    } catch (error) {
      console.warn('Failed to load pitcher exit velocity data:', error);
    }
  }

  /**
   * Load comprehensive custom batter data with expected statistics
   */
  async loadCustomBatterData() {
    try {
      const response = await fetch('/data/stats/custom_batter_2025.csv');
      const csvText = await response.text();
      
      return new Promise((resolve) => {
        Papa.parse(csvText, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            let count = 0;
            results.data.forEach(row => {
              const playerName = this.normalizeName(row['last_name, first_name']);
              if (playerName) {
                this.customBatters.set(playerName, {
                  // Traditional stats
                  ab: parseInt(row.ab) || 0,
                  pa: parseInt(row.pa) || 0,
                  hit: parseInt(row.hit) || 0,
                  homeRun: parseInt(row.home_run) || 0,
                  strikeout: parseInt(row.strikeout) || 0,
                  walk: parseInt(row.walk) || 0,
                  
                  // Rate stats
                  battingAvg: parseFloat(row.batting_avg) || 0,
                  onBasePercent: parseFloat(row.on_base_percent) || 0,
                  sluggingPercent: parseFloat(row.slg_percent) || 0,
                  ops: parseFloat(row.on_base_plus_slg) || 0,
                  isolatedPower: parseFloat(row.isolated_power) || 0,
                  babip: parseFloat(row.babip) || 0,
                  kPercent: parseFloat(row.k_percent) || 0,
                  bbPercent: parseFloat(row.bb_percent) || 0,
                  
                  // Expected statistics
                  xba: parseFloat(row.xba) || 0,
                  xslg: parseFloat(row.xslg) || 0,
                  xwoba: parseFloat(row.xwoba) || 0,
                  woba: parseFloat(row.woba) || 0,
                  xobp: parseFloat(row.xobp) || 0,
                  xiso: parseFloat(row.xiso) || 0,
                  
                  // Expected stats regression opportunities
                  xbaDiff: parseFloat(row.xbadiff) || 0,
                  xslgDiff: parseFloat(row.xslgdiff) || 0,
                  wobaDiff: parseFloat(row.wobadiff) || 0,
                  
                  // Contact quality
                  barrel: parseInt(row.barrel) || 0,
                  barrelBattedRate: parseFloat(row.barrel_batted_rate) || 0,
                  hardHitPercent: parseFloat(row.hard_hit_percent) || 0,
                  sweetSpotPercent: parseFloat(row.sweet_spot_percent) || 0,
                  exitVelocityAvg: parseFloat(row.exit_velocity_avg) || 0,
                  launchAngleAvg: parseFloat(row.launch_angle_avg) || 0,
                  solidContactPercent: parseFloat(row.solidcontact_percent) || 0,
                  
                  // Plate discipline
                  zSwingPercent: parseFloat(row.z_swing_percent) || 0,
                  ozSwingPercent: parseFloat(row.oz_swing_percent) || 0,
                  whiffPercent: parseFloat(row.whiff_percent) || 0,
                  swingPercent: parseFloat(row.swing_percent) || 0,
                  
                  // Advanced swing metrics
                  avgSwingSpeed: parseFloat(row.avg_swing_speed) || 0,
                  fastSwingRate: parseFloat(row.fast_swing_rate) || 0,
                  blastsContact: parseFloat(row.blasts_contact) || 0,
                  blastsSwing: parseFloat(row.blasts_swing) || 0,
                  squaredUpContact: parseFloat(row.squared_up_contact) || 0,
                  squaredUpSwing: parseFloat(row.squared_up_swing) || 0,
                  avgSwingLength: parseFloat(row.avg_swing_length) || 0,
                  attackAngle: parseFloat(row.attack_angle) || 0,
                  idealAngleRate: parseFloat(row.ideal_angle_rate) || 0,
                  
                  // Metadata
                  playerId: row.player_id || '',
                  playerAge: parseInt(row.player_age) || 0,
                  sprintSpeed: parseFloat(row.sprint_speed) || 0,
                  dataQuality: this.assessDataQuality(parseInt(row.pa) || 0, 'batter')
                });
                count++;
              }
            });
            console.log(`   📈 Loaded comprehensive data for ${count} batters`);
            resolve();
          }
        });
      });
    } catch (error) {
      console.warn('Failed to load custom batter data:', error);
    }
  }

  /**
   * Load comprehensive custom pitcher data with expected statistics
   */
  async loadCustomPitcherData() {
    try {
      const response = await fetch('/data/stats/custom_pitcher_2025.csv');
      const csvText = await response.text();
      
      return new Promise((resolve) => {
        Papa.parse(csvText, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            let count = 0;
            results.data.forEach(row => {
              const playerName = this.normalizeName(row['last_name, first_name']);
              if (playerName) {
                this.customPitchers.set(playerName, {
                  // Basic stats
                  games: parseInt(row.p_game) || 0,
                  inningsPitched: parseFloat(row.p_formatted_ip) || 0,
                  era: parseFloat(row.p_era) || 0,
                  
                  // Batters faced stats
                  pa: parseInt(row.pa) || 0,
                  ab: parseInt(row.ab) || 0,
                  hitsAllowed: parseInt(row.hit) || 0,
                  homeRunsAllowed: parseInt(row.home_run) || 0,
                  strikeouts: parseInt(row.strikeout) || 0,
                  walks: parseInt(row.walk) || 0,
                  
                  // Opponent rate stats
                  oppBattingAvg: parseFloat(row.batting_avg) || 0,
                  oppOnBasePercent: parseFloat(row.on_base_percent) || 0,
                  oppSluggingPercent: parseFloat(row.slg_percent) || 0,
                  oppOPS: parseFloat(row.on_base_plus_slg) || 0,
                  oppIsolatedPower: parseFloat(row.isolated_power) || 0,
                  oppBabip: parseFloat(row.babip) || 0,
                  kPercent: parseFloat(row.k_percent) || 0,
                  bbPercent: parseFloat(row.bb_percent) || 0,
                  
                  // Expected statistics allowed
                  xbaAllowed: parseFloat(row.xba) || 0,
                  xslgAllowed: parseFloat(row.xslg) || 0,
                  xwobaAllowed: parseFloat(row.xwoba) || 0,
                  wobaAllowed: parseFloat(row.woba) || 0,
                  
                  // Expected stats regression vulnerabilities
                  xbaDiff: parseFloat(row.xbadiff) || 0,
                  xslgDiff: parseFloat(row.xslgdiff) || 0,
                  wobaDiff: parseFloat(row.wobadiff) || 0,
                  
                  // Contact quality allowed
                  barrelsAllowed: parseInt(row.barrel) || 0,
                  barrelBattedRateAllowed: parseFloat(row.barrel_batted_rate) || 0,
                  hardHitPercentAllowed: parseFloat(row.hard_hit_percent) || 0,
                  sweetSpotPercentAllowed: parseFloat(row.sweet_spot_percent) || 0,
                  exitVelocityAvgAllowed: parseFloat(row.exit_velocity_avg) || 0,
                  launchAngleAvgAllowed: parseFloat(row.launch_angle_avg) || 0,
                  
                  // Arsenal data
                  pitchHand: row.pitch_hand || 'R',
                  armAngle: parseFloat(row.arm_angle) || 0,
                  
                  // Metadata
                  playerId: row.player_id || '',
                  playerAge: parseInt(row.player_age) || 0,
                  dataQuality: this.assessDataQuality(parseInt(row.pa) || 0, 'pitcher')
                });
                count++;
              }
            });
            console.log(`   🏹 Loaded comprehensive data for ${count} pitchers`);
            resolve();
          }
        });
      });
    } catch (error) {
      console.warn('Failed to load custom pitcher data:', error);
    }
  }

  /**
   * Load pitcher arsenal data by pitch type
   */
  async loadPitcherArsenalData() {
    try {
      const response = await fetch('/data/stats/pitcherpitcharsenalstats_2025.csv');
      const csvText = await response.text();
      
      return new Promise((resolve) => {
        Papa.parse(csvText, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            let count = 0;
            results.data.forEach(row => {
              const pitcherName = this.normalizeName(row['last_name, first_name']);
              if (pitcherName) {
                if (!this.pitcherArsenal.has(pitcherName)) {
                  this.pitcherArsenal.set(pitcherName, {
                    team: row.team_name_alt || '',
                    pitchTypes: new Map()
                  });
                }
                
                const pitchType = row.pitch_type;
                const pitchData = {
                  pitchName: row.pitch_name || '',
                  runValuePer100: parseFloat(row.run_value_per_100) || 0,
                  usage: parseFloat(row.pitch_usage) || 0,
                  baAgainst: parseFloat(row.ba) || 0,
                  slgAgainst: parseFloat(row.slg) || 0,
                  wobaAgainst: parseFloat(row.woba) || 0,
                  whiffPercent: parseFloat(row.whiff_percent) || 0,
                  hardHitPercent: parseFloat(row.hard_hit_percent) || 0,
                  kPercent: parseFloat(row.k_percent) || 0,
                  pitches: parseInt(row.pitches) || 0
                };
                
                this.pitcherArsenal.get(pitcherName).pitchTypes.set(pitchType, pitchData);
                count++;
              }
            });
            console.log(`   🎯 Loaded arsenal data for ${this.pitcherArsenal.size} pitchers`);
            resolve();
          }
        });
      });
    } catch (error) {
      console.warn('Failed to load pitcher arsenal data:', error);
    }
  }

  /**
   * Load handedness-specific batted ball data (16 scenarios)
   */
  async loadHandednessData() {
    const handednessFiles = [
      { file: 'batters-batted-ball-bat-left-pitch-hand-left-2025.csv', batHand: 'L', pitchHand: 'L' },
      { file: 'batters-batted-ball-bat-left-pitch-hand-right-2025.csv', batHand: 'L', pitchHand: 'R' },
      { file: 'batters-batted-ball-bat-right-pitch-hand-left-2025.csv', batHand: 'R', pitchHand: 'L' },
      { file: 'batters-batted-ball-bat-right-pitch-hand-right-2025.csv', batHand: 'R', pitchHand: 'R' }
    ];
    
    for (const config of handednessFiles) {
      try {
        const response = await fetch(`/data/stats/${config.file}`);
        const csvText = await response.text();
        
        await new Promise((resolve) => {
          Papa.parse(csvText, {
            header: true,
            skipEmptyLines: true,
            complete: (results) => {
              let count = 0;
              results.data.forEach(row => {
                const batterName = this.normalizeName(row.name);
                if (batterName) {
                  if (!this.handednessData.has(batterName)) {
                    this.handednessData.set(batterName, new Map());
                  }
                  
                  const matchupKey = `${config.batHand}v${config.pitchHand}`;
                  this.handednessData.get(batterName).set(matchupKey, {
                    bbe: parseInt(row.bbe) || 0,
                    gbRate: parseFloat(row.gb_rate) || 0,
                    airRate: parseFloat(row.air_rate) || 0,
                    fbRate: parseFloat(row.fb_rate) || 0,
                    ldRate: parseFloat(row.ld_rate) || 0,
                    pullRate: parseFloat(row.pull_rate) || 0,
                    oppoRate: parseFloat(row.oppo_rate) || 0,
                    pullAirRate: parseFloat(row.pull_air_rate) || 0
                  });
                  count++;
                }
              });
              console.log(`   📊 Loaded ${config.file}: ${count} records`);
              resolve();
            }
          });
        });
      } catch (error) {
        console.warn(`Failed to load ${config.file}:`, error);
      }
    }
  }

  /**
   * Load swing path data
   */
  async loadSwingPathData() {
    const swingPathFiles = ['batters-swing-path-all.csv', 'batters-swing-path-LHP.csv', 'batters-swing-path-RHP.csv'];
    
    for (const file of swingPathFiles) {
      try {
        const response = await fetch(`/data/stats/${file}`);
        const csvText = await response.text();
        
        await new Promise((resolve) => {
          Papa.parse(csvText, {
            header: true,
            skipEmptyLines: true,
            complete: (results) => {
              let count = 0;
              results.data.forEach(row => {
                const batterName = this.normalizeName(row.name);
                if (batterName) {
                  if (!this.swingPathData.has(batterName)) {
                    this.swingPathData.set(batterName, new Map());
                  }
                  
                  const context = file.includes('LHP') ? 'vs_LHP' : file.includes('RHP') ? 'vs_RHP' : 'overall';
                  this.swingPathData.get(batterName).set(context, {
                    avgSwingLength: parseFloat(row.avg_swing_length) || 0,
                    avgSwingSpeed: parseFloat(row.avg_swing_speed) || 0,
                    attackAngle: parseFloat(row.attack_angle) || 0,
                    verticalPath: parseFloat(row.vertical_swing_path) || 0,
                    swords: parseFloat(row.swords) || 0
                  });
                  count++;
                }
              });
              console.log(`   🏏 Loaded ${file}: ${count} records`);
              resolve();
            }
          });
        });
      } catch (error) {
        console.warn(`Failed to load ${file}:`, error);
      }
    }
  }

  /**
   * Load bat tracking data
   */
  async loadBatTrackingData() {
    const batTrackingFiles = ['bat-tracking-swing-path-all.csv', 'bat-tracking-swing-path-LHP.csv', 'bat-tracking-swing-path-RHP.csv'];
    
    for (const file of batTrackingFiles) {
      try {
        const response = await fetch(`/data/stats/${file}`);
        const csvText = await response.text();
        
        await new Promise((resolve) => {
          Papa.parse(csvText, {
            header: true,
            skipEmptyLines: true,
            complete: (results) => {
              let count = 0;
              results.data.forEach(row => {
                const batterName = this.normalizeName(row.name);
                if (batterName) {
                  if (!this.batTrackingData.has(batterName)) {
                    this.batTrackingData.set(batterName, new Map());
                  }
                  
                  const context = file.includes('LHP') ? 'vs_LHP' : file.includes('RHP') ? 'vs_RHP' : 'overall';
                  this.batTrackingData.get(batterName).set(context, {
                    blastMetrics: parseFloat(row.blast_metrics) || 0,
                    timeToContact: parseFloat(row.time_to_contact) || 0,
                    batSpeed: parseFloat(row.bat_speed) || 0,
                    rotationalAcceleration: parseFloat(row.rotational_acceleration) || 0
                  });
                  count++;
                }
              });
              console.log(`   🏸 Loaded ${file}: ${count} records`);
              resolve();
            }
          });
        });
      } catch (error) {
        console.warn(`Failed to load ${file}:`, error);
      }
    }
  }

  /**
   * Generate comprehensive exploiters using all available data
   */
  async generateComprehensiveExploiters(games, currentDate) {
    const exploiters = [];
    
    for (const game of games.slice(0, 10)) { // Analyze up to 10 games
      try {
        const homeTeam = game.teams?.home?.abbr || game.homeTeam;
        const awayTeam = game.teams?.away?.abbr || game.awayTeam;
        const homePitcher = game.pitchers?.home?.name || game.homePitcher;
        const awayPitcher = game.pitchers?.away?.name || game.awayPitcher;
        const venue = game.venue?.name || game.venue || 'Unknown';
        
        console.log(`🏟️ Analyzing: ${awayTeam}@${homeTeam} at ${venue}`);
        
        // Get team lineups
        const awayHitters = await this.getTeamHitters(awayTeam, currentDate);
        const homeHitters = await this.getTeamHitters(homeTeam, currentDate);
        
        // Analyze pitcher vulnerabilities
        const homePitcherVulns = this.analyzeEnhancedPitcherVulnerabilities(homePitcher);
        const awayPitcherVulns = this.analyzeEnhancedPitcherVulnerabilities(awayPitcher);
        
        console.log(`   🎯 ${homePitcher}: Vulnerability Score ${homePitcherVulns.vulnerabilityScore}/100`);
        console.log(`   🎯 ${awayPitcher}: Vulnerability Score ${awayPitcherVulns.vulnerabilityScore}/100`);
        
        // Analyze away hitters vs home pitcher
        for (const hitter of awayHitters) {
          const exploitAnalysis = this.analyzeEnhancedBatterExploitPotential(
            hitter.name, 
            homePitcher, 
            homePitcherVulns, 
            venue,
            awayTeam,
            homeTeam
          );
          
          if (exploitAnalysis.exploitScore >= 45) { // Dynamic threshold
            exploiters.push({
              player: hitter.name,
              team: awayTeam,
              pitcher: homePitcher,
              opposingTeam: homeTeam,
              venue: venue,
              exploitIndex: exploitAnalysis.exploitScore,
              confidence: exploitAnalysis.confidence,
              combinedScore: exploitAnalysis.exploitScore * exploitAnalysis.confidence,
              batterClassification: exploitAnalysis.classification,
              keyWeakness: exploitAnalysis.keyWeakness,
              comprehensiveJustification: exploitAnalysis.comprehensiveJustification,
              exploitFactors: exploitAnalysis.factors,
              situationalAdvantages: exploitAnalysis.situationalAdvantages,
              regressionOpportunity: exploitAnalysis.regressionOpportunity,
              contactQualityEdge: exploitAnalysis.contactQualityEdge,
              handednessAnalysis: exploitAnalysis.handednessAnalysis,
              parkAdjustment: exploitAnalysis.parkAdjustment,
              dataQuality: exploitAnalysis.dataQuality,
              analysisTimestamp: new Date().toISOString()
            });
          }
        }
        
        // Analyze home hitters vs away pitcher
        for (const hitter of homeHitters) {
          const exploitAnalysis = this.analyzeEnhancedBatterExploitPotential(
            hitter.name, 
            awayPitcher, 
            awayPitcherVulns, 
            venue,
            homeTeam,
            awayTeam
          );
          
          if (exploitAnalysis.exploitScore >= 45) {
            exploiters.push({
              player: hitter.name,
              team: homeTeam,
              pitcher: awayPitcher,
              opposingTeam: awayTeam,
              venue: venue,
              exploitIndex: exploitAnalysis.exploitScore,
              confidence: exploitAnalysis.confidence,
              combinedScore: exploitAnalysis.exploitScore * exploitAnalysis.confidence,
              batterClassification: exploitAnalysis.classification,
              keyWeakness: exploitAnalysis.keyWeakness,
              comprehensiveJustification: exploitAnalysis.comprehensiveJustification,
              exploitFactors: exploitAnalysis.factors,
              situationalAdvantages: exploitAnalysis.situationalAdvantages,
              regressionOpportunity: exploitAnalysis.regressionOpportunity,
              contactQualityEdge: exploitAnalysis.contactQualityEdge,
              handednessAnalysis: exploitAnalysis.handednessAnalysis,
              parkAdjustment: exploitAnalysis.parkAdjustment,
              dataQuality: exploitAnalysis.dataQuality,
              analysisTimestamp: new Date().toISOString()
            });
          }
        }
        
      } catch (error) {
        console.warn(`Error analyzing game: ${error.message}`);
      }
    }
    
    return exploiters;
  }

  /**
   * Enhanced pitcher vulnerability analysis with comprehensive data
   */
  analyzeEnhancedPitcherVulnerabilities(pitcherName) {
    const normalizedName = this.normalizeName(pitcherName);
    
    const analysis = {
      vulnerabilities: [],
      vulnerabilityScore: 50, // Base score
      confidence: 0.4,
      dataQuality: 'limited',
      regressionVulnerabilities: [],
      contactQualityVulnerabilities: [],
      arsenalWeaknesses: [],
      modernMetrics: {}
    };
    
    let totalVulnerabilityPoints = 0;
    const vulnerabilityFactors = [];
    
    // 1. Expected Statistics Regression Analysis
    if (this.customPitchers.has(normalizedName)) {
      const pitcherData = this.customPitchers.get(normalizedName);
      
      // xBA regression (pitcher allowing fewer hits than expected = due for regression)
      if (pitcherData.xbaDiff < -0.015) { // Significantly outperforming xBA
        const regressionRisk = Math.abs(pitcherData.xbaDiff) * 500; // Scale to points
        totalVulnerabilityPoints += regressionRisk;
        vulnerabilityFactors.push(`xBA regression risk (${(pitcherData.xbaDiff * -1000).toFixed(0)} points)`);
        analysis.regressionVulnerabilities.push({
          type: 'xBA_regression',
          risk: regressionRisk,
          differential: pitcherData.xbaDiff
        });
      }
      
      // xSLG regression
      if (pitcherData.xslgDiff < -0.025) {
        const powerRegressionRisk = Math.abs(pitcherData.xslgDiff) * 400;
        totalVulnerabilityPoints += powerRegressionRisk;
        vulnerabilityFactors.push(`Power regression risk (${(pitcherData.xslgDiff * -1000).toFixed(0)} points)`);
        analysis.regressionVulnerabilities.push({
          type: 'xSLG_regression',
          risk: powerRegressionRisk,
          differential: pitcherData.xslgDiff
        });
      }
      
      // wOBA regression
      if (pitcherData.wobaDiff < -0.020) {
        const overallRegressionRisk = Math.abs(pitcherData.wobaDiff) * 600;
        totalVulnerabilityPoints += overallRegressionRisk;
        vulnerabilityFactors.push(`Overall performance regression risk`);
        analysis.regressionVulnerabilities.push({
          type: 'wOBA_regression',
          risk: overallRegressionRisk,
          differential: pitcherData.wobaDiff
        });
      }
      
      analysis.confidence += 0.25;
      analysis.modernMetrics.expectedStats = {
        xbaAllowed: pitcherData.xbaAllowed,
        xslgAllowed: pitcherData.xslgAllowed,
        wobaAllowed: pitcherData.wobaAllowed,
        regressionRisk: analysis.regressionVulnerabilities.length > 0 ? 'high' : 'low'
      };
    }
    
    // 2. Contact Quality Vulnerability Analysis
    if (this.pitcherExitVelocity.has(normalizedName)) {
      const exitVelData = this.pitcherExitVelocity.get(normalizedName);
      
      // Barrel rate vulnerability (league average ~7.5%)
      const leagueAvgBarrel = 7.5;
      if (exitVelData.realBarrelRateAllowed > leagueAvgBarrel * 1.25) { // 25% above average
        const barrelVulnerability = (exitVelData.realBarrelRateAllowed - leagueAvgBarrel) * 4;
        totalVulnerabilityPoints += barrelVulnerability;
        vulnerabilityFactors.push(`Extreme barrel rate allowed (${exitVelData.realBarrelRateAllowed.toFixed(1)}%)`);
        analysis.contactQualityVulnerabilities.push({
          type: 'barrel_vulnerability',
          severity: 'extreme',
          rate: exitVelData.realBarrelRateAllowed
        });
      } else if (exitVelData.realBarrelRateAllowed > leagueAvgBarrel * 1.10) {
        const barrelVulnerability = (exitVelData.realBarrelRateAllowed - leagueAvgBarrel) * 2;
        totalVulnerabilityPoints += barrelVulnerability;
        vulnerabilityFactors.push(`High barrel rate allowed (${exitVelData.realBarrelRateAllowed.toFixed(1)}%)`);
        analysis.contactQualityVulnerabilities.push({
          type: 'barrel_vulnerability',
          severity: 'high',
          rate: exitVelData.realBarrelRateAllowed
        });
      }
      
      // Hard hit rate vulnerability
      if (exitVelData.hardHitPercentAllowed > 45) { // Top 20% worst
        totalVulnerabilityPoints += 25;
        vulnerabilityFactors.push(`Extreme hard contact allowed (${exitVelData.hardHitPercentAllowed.toFixed(1)}%)`);
        analysis.contactQualityVulnerabilities.push({
          type: 'hard_contact_vulnerability',
          severity: 'extreme',
          rate: exitVelData.hardHitPercentAllowed
        });
      }
      
      // Sweet spot vulnerability
      if (exitVelData.sweetSpotPercentAllowed > 35) {
        totalVulnerabilityPoints += 15;
        vulnerabilityFactors.push(`High sweet spot contact allowed`);
        analysis.contactQualityVulnerabilities.push({
          type: 'sweet_spot_vulnerability',
          rate: exitVelData.sweetSpotPercentAllowed
        });
      }
      
      analysis.confidence += 0.25;
      analysis.modernMetrics.contactQuality = {
        barrelRateAllowed: exitVelData.realBarrelRateAllowed,
        hardHitAllowed: exitVelData.hardHitPercentAllowed,
        avgExitVelocityAllowed: exitVelData.avgHitSpeedAllowed
      };
    }
    
    // 3. Arsenal Analysis
    if (this.pitcherArsenal.has(normalizedName)) {
      const arsenalData = this.pitcherArsenal.get(normalizedName);
      
      // Analyze pitch effectiveness
      for (const [pitchType, pitchData] of arsenalData.pitchTypes) {
        // High BA against specific pitches
        if (pitchData.baAgainst > 0.280 && pitchData.usage > 15) {
          totalVulnerabilityPoints += 12;
          vulnerabilityFactors.push(`Vulnerable ${pitchData.pitchName} (${(pitchData.baAgainst * 1000).toFixed(0)} BA against)`);
          analysis.arsenalWeaknesses.push({
            pitch: pitchData.pitchName,
            weakness: 'high_ba_against',
            value: pitchData.baAgainst,
            usage: pitchData.usage
          });
        }
        
        // Low whiff rates on breaking balls
        if (pitchData.pitchName.toLowerCase().includes('slider') || 
            pitchData.pitchName.toLowerCase().includes('curve')) {
          if (pitchData.whiffPercent < 25 && pitchData.usage > 10) {
            totalVulnerabilityPoints += 10;
            vulnerabilityFactors.push(`Ineffective ${pitchData.pitchName} (${pitchData.whiffPercent.toFixed(1)}% whiff)`);
            analysis.arsenalWeaknesses.push({
              pitch: pitchData.pitchName,
              weakness: 'low_whiff_rate',
              value: pitchData.whiffPercent,
              usage: pitchData.usage
            });
          }
        }
      }
      
      analysis.confidence += 0.2;
    }
    
    // Calculate final vulnerability score
    analysis.vulnerabilityScore = Math.min(100, 50 + totalVulnerabilityPoints);
    
    // Create comprehensive vulnerability profile
    if (totalVulnerabilityPoints >= 35 && vulnerabilityFactors.length >= 2) {
      analysis.vulnerabilities.push({
        category: 'comprehensive_vulnerability_analysis',
        vulnerabilityScore: analysis.vulnerabilityScore,
        factors: vulnerabilityFactors.slice(0, 6), // Top 6 factors
        confidenceLevel: analysis.vulnerabilityScore >= 75 ? 'high' : 'moderate',
        regressionRisk: analysis.regressionVulnerabilities.length > 0 ? 'elevated' : 'normal',
        contactQualityRisk: analysis.contactQualityVulnerabilities.length > 0 ? 'elevated' : 'normal'
      });
    }
    
    // Data quality assessment
    const dataSourcesAvailable = [
      this.customPitchers.has(normalizedName),
      this.pitcherExitVelocity.has(normalizedName),
      this.pitcherArsenal.has(normalizedName)
    ].filter(Boolean).length;
    
    analysis.confidence = Math.min(0.95, 0.4 + (dataSourcesAvailable * 0.15));
    analysis.dataQuality = ['limited', 'fair', 'good', 'excellent'][Math.min(3, dataSourcesAvailable)];
    
    return analysis;
  }

  /**
   * Enhanced batter exploit potential analysis
   */
  analyzeEnhancedBatterExploitPotential(batterName, pitcherName, pitcherVulns, venue, batterTeam, pitcherTeam) {
    const normalizedBatter = this.normalizeName(batterName);
    const normalizedPitcher = this.normalizeName(pitcherName);
    
    const analysis = {
      exploitScore: 50, // Base score
      confidence: 0.4,
      classification: 'unknown',
      keyWeakness: 'General matchup analysis',
      factors: [],
      situationalAdvantages: [],
      regressionOpportunity: null,
      contactQualityEdge: null,
      handednessAnalysis: null,
      parkAdjustment: 1.0,
      dataQuality: 'limited'
    };
    
    // 1. Expected Performance Regression Matching
    if (this.customBatters.has(normalizedBatter)) {
      const batterData = this.customBatters.get(normalizedBatter);
      
      // Positive xBA diff = due for improvement
      if (batterData.xbaDiff > 0.015) {
        const regressionBoost = batterData.xbaDiff * 400;
        analysis.exploitScore += regressionBoost;
        analysis.factors.push({
          type: 'xBA_regression_opportunity',
          description: `Due for batting avg improvement (+${(batterData.xbaDiff * 1000).toFixed(0)} points)`,
          value: batterData.xbaDiff,
          impact: regressionBoost
        });
        analysis.regressionOpportunity = {
          type: 'positive_xBA_regression',
          boost: regressionBoost,
          differential: batterData.xbaDiff
        };
        
        // Extra boost if pitcher also has regression vulnerability
        if (pitcherVulns.regressionVulnerabilities.some(v => v.type === 'xBA_regression')) {
          analysis.exploitScore += 15;
          analysis.situationalAdvantages.push("Regressing batter vs regressing pitcher");
          analysis.factors.push({
            type: 'double_regression_opportunity',
            description: 'Both batter and pitcher due for regression',
            impact: 15
          });
        }
      }
      
      // Positive xSLG diff = due for power improvement
      if (batterData.xslgDiff > 0.025) {
        const powerRegressionBoost = batterData.xslgDiff * 300;
        analysis.exploitScore += powerRegressionBoost;
        analysis.factors.push({
          type: 'xSLG_regression_opportunity',
          description: `Power regression due (+${(batterData.xslgDiff * 1000).toFixed(0)} SLG points)`,
          value: batterData.xslgDiff,
          impact: powerRegressionBoost
        });
        if (!analysis.regressionOpportunity) {
          analysis.regressionOpportunity = {
            type: 'positive_xSLG_regression',
            boost: powerRegressionBoost,
            differential: batterData.xslgDiff
          };
        }
      }
      
      // wOBA regression opportunity
      if (batterData.wobaDiff > 0.020) {
        const wobaRegressionBoost = batterData.wobaDiff * 500;
        analysis.exploitScore += wobaRegressionBoost;
        analysis.factors.push({
          type: 'wOBA_regression_opportunity',
          description: `Overall performance regression due (+${(batterData.wobaDiff * 1000).toFixed(0)} wOBA points)`,
          value: batterData.wobaDiff,
          impact: wobaRegressionBoost
        });
      }
      
      analysis.confidence += 0.25;
    }
    
    // 2. Contact Quality Matching
    if (this.hitterExitVelocity.has(normalizedBatter)) {
      const hitterEV = this.hitterExitVelocity.get(normalizedBatter);
      
      // Elite barrel rate
      if (hitterEV.realBarrelRate >= 12) { // Elite level
        analysis.exploitScore += 20;
        analysis.factors.push({
          type: 'elite_barrel_rate',
          description: `Elite barrel rate (${hitterEV.realBarrelRate.toFixed(1)}%)`,
          value: hitterEV.realBarrelRate,
          percentile: 'top_5_percent',
          impact: 20
        });
        analysis.classification = 'elite_power';
        
        // Massive boost if pitcher allows high barrel rates
        if (pitcherVulns.contactQualityVulnerabilities.some(v => v.type === 'barrel_vulnerability')) {
          const pitcherBarrelVuln = pitcherVulns.contactQualityVulnerabilities.find(v => v.type === 'barrel_vulnerability');
          analysis.exploitScore += 25;
          analysis.situationalAdvantages.push("Elite barrel hitter vs barrel-vulnerable pitcher");
          analysis.contactQualityEdge = {
            type: 'barrel_exploitation',
            hitterRate: hitterEV.realBarrelRate,
            pitcherVulnerability: 'high',
            pitcherRate: pitcherBarrelVuln.rate
          };
          analysis.factors.push({
            type: 'barrel_exploitation_matchup',
            description: `Barrel exploitation opportunity (${hitterEV.realBarrelRate.toFixed(1)}% vs ${pitcherBarrelVuln.rate.toFixed(1)}% allowed)`,
            hitterValue: hitterEV.realBarrelRate,
            pitcherValue: pitcherBarrelVuln.rate,
            impact: 25
          });
        }
      } else if (hitterEV.realBarrelRate >= 8) { // Above average
        analysis.exploitScore += 10;
        analysis.factors.push({
          type: 'strong_barrel_rate',
          description: `Strong barrel rate (${hitterEV.realBarrelRate.toFixed(1)}%)`,
          value: hitterEV.realBarrelRate,
          percentile: 'above_average',
          impact: 10
        });
      }
      
      // Max exit velocity relevance
      if (hitterEV.maxHitSpeed >= 115) {
        analysis.exploitScore += 8;
        analysis.factors.push({
          type: 'elite_exit_velocity',
          description: `Elite max exit velocity (${hitterEV.maxHitSpeed.toFixed(1)} mph)`,
          value: hitterEV.maxHitSpeed,
          impact: 8
        });
        
        if (pitcherVulns.contactQualityVulnerabilities.some(v => v.type === 'hard_contact_vulnerability')) {
          analysis.exploitScore += 12;
          analysis.situationalAdvantages.push("Elite power vs hard contact vulnerability");
          analysis.factors.push({
            type: 'hard_contact_exploitation',
            description: 'Elite power vs hard contact vulnerability',
            impact: 12
          });
        }
      }
      
      // Sweet spot percentage
      if (hitterEV.sweetSpotPercent >= 35) {
        analysis.exploitScore += 6;
        analysis.factors.push({
          type: 'high_sweet_spot_rate',
          description: `High sweet spot rate (${hitterEV.sweetSpotPercent.toFixed(1)}%)`,
          value: hitterEV.sweetSpotPercent,
          impact: 6
        });
      }
      
      analysis.confidence += 0.25;
    }
    
    // 3. Advanced Handedness Analysis (16 scenarios)
    const handednessAnalysis = this.analyzeHandednessMatchup(normalizedBatter, normalizedPitcher);
    if (handednessAnalysis.advantage > 0) {
      analysis.exploitScore += handednessAnalysis.advantage;
      analysis.handednessAnalysis = handednessAnalysis;
      if (handednessAnalysis.advantage >= 15) {
        analysis.situationalAdvantages.push(handednessAnalysis.description);
      }
    }
    
    // 4. Arsenal-Specific Matching
    if (this.pitcherArsenal.has(normalizedPitcher) && this.customBatters.has(normalizedBatter)) {
      const arsenalMatchup = this.analyzeArsenalMatchup(normalizedBatter, normalizedPitcher);
      if (arsenalMatchup.exploitScore > 0) {
        analysis.exploitScore += arsenalMatchup.exploitScore;
        analysis.keyWeakness = arsenalMatchup.keyWeakness;
        if (arsenalMatchup.situationalAdvantage) {
          analysis.situationalAdvantages.push(arsenalMatchup.situationalAdvantage);
        }
      }
    }
    
    // 5. Swing Mechanics Matching
    if (this.swingPathData.has(normalizedBatter)) {
      const swingAnalysis = this.analyzeSwingMechanicsAdvantage(normalizedBatter, pitcherVulns);
      if (swingAnalysis.advantage > 0) {
        analysis.exploitScore += swingAnalysis.advantage;
        analysis.factors.push({
          type: 'swing_mechanics_advantage',
          description: swingAnalysis.factor,
          value: swingAnalysis.value,
          impact: swingAnalysis.advantage
        });
      }
    }
    
    // 6. Classification System
    if (analysis.exploitScore >= 85) {
      analysis.classification = 'elite_opportunity';
    } else if (analysis.exploitScore >= 70) {
      analysis.classification = 'strong_opportunity';
    } else if (analysis.exploitScore >= 55) {
      analysis.classification = 'moderate_opportunity';
    } else {
      analysis.classification = 'marginal_opportunity';
    }
    
    // Final confidence adjustment
    const dataPointsAvailable = [
      this.customBatters.has(normalizedBatter),
      this.hitterExitVelocity.has(normalizedBatter),
      this.handednessData.has(normalizedBatter),
      this.swingPathData.has(normalizedBatter)
    ].filter(Boolean).length;
    
    analysis.confidence = Math.min(0.95, 0.4 + (dataPointsAvailable * 0.12));
    analysis.dataQuality = ['limited', 'fair', 'good', 'excellent'][Math.min(3, dataPointsAvailable)];
    
    // 7. Generate comprehensive justification combining all factors
    analysis.comprehensiveJustification = this.generateComprehensiveJustification(
      normalizedBatter, 
      normalizedPitcher, 
      pitcherVulns, 
      analysis
    );
    
    return analysis;
  }

  /**
   * Generate comprehensive justification combining all vulnerability factors
   */
  generateComprehensiveJustification(batterName, pitcherName, pitcherVulns, analysis) {
    const justificationParts = [];
    
    // 1. Contact Quality Analysis
    if (this.hitterExitVelocity.has(batterName) && this.pitcherExitVelocity.has(pitcherName)) {
      const hitterEV = this.hitterExitVelocity.get(batterName);
      const pitcherEV = this.pitcherExitVelocity.get(pitcherName);
      
      // Barrel rate matchup
      if (hitterEV.realBarrelRate >= 8 && pitcherEV.realBarrelRateAllowed >= 8.5) {
        justificationParts.push(
          `Elite barrel matchup (${hitterEV.realBarrelRate.toFixed(1)}% vs ${pitcherEV.realBarrelRateAllowed.toFixed(1)}% allowed)`
        );
      } else if (pitcherEV.realBarrelRateAllowed >= 9.0) {
        justificationParts.push(
          `Extreme barrel rate allowed (${pitcherEV.realBarrelRateAllowed.toFixed(1)}% vs 7.5% league avg)`
        );
      }
      
      // Hard hit rate vulnerability
      if (pitcherEV.hardHitPercentAllowed >= 42) {
        justificationParts.push(
          `High hard contact allowed (${pitcherEV.hardHitPercentAllowed.toFixed(1)}%)`
        );
      }
    }
    
    // 2. Arsenal Vulnerability Analysis
    if (this.pitcherArsenal.has(pitcherName)) {
      const arsenalData = this.pitcherArsenal.get(pitcherName);
      const vulnerablePitches = [];
      
      for (const [pitchType, pitchData] of arsenalData.pitchTypes) {
        if (pitchData.baAgainst > 0.280 && pitchData.usage > 15) {
          vulnerablePitches.push({
            name: pitchData.pitchName,
            ba: pitchData.baAgainst,
            usage: pitchData.usage
          });
        }
      }
      
      if (vulnerablePitches.length > 0) {
        const mostVulnerable = vulnerablePitches.sort((a, b) => b.ba - a.ba)[0];
        justificationParts.push(
          `Vulnerable ${mostVulnerable.name} (.${(mostVulnerable.ba * 1000).toFixed(0)} BA, ${mostVulnerable.usage.toFixed(1)}% usage)`
        );
      }
    }
    
    // 3. Expected Stats Regression Analysis
    if (this.customBatters.has(batterName) && this.customPitchers.has(pitcherName)) {
      const batterData = this.customBatters.get(batterName);
      const pitcherData = this.customPitchers.get(pitcherName);
      
      // Batter due for improvement
      if (batterData.xbaDiff > 0.015) {
        justificationParts.push(
          `Batter due for avg improvement (+${(batterData.xbaDiff * 1000).toFixed(0)} points)`
        );
      }
      
      if (batterData.xslgDiff > 0.025) {
        justificationParts.push(
          `Power regression due (+${(batterData.xslgDiff * 1000).toFixed(0)} SLG points)`
        );
      }
      
      // Pitcher regression vulnerability
      if (pitcherData.xbaDiff < -0.015) {
        justificationParts.push(
          `Pitcher regression risk (${(pitcherData.xbaDiff * -1000).toFixed(0)} points below expected)`
        );
      }
      
      if (pitcherData.xslgDiff < -0.025) {
        justificationParts.push(
          `Power regression vulnerability (${(pitcherData.xslgDiff * -1000).toFixed(0)} SLG points)`
        );
      }
    }
    
    // 4. Handedness & Situational Advantages
    if (analysis.handednessAnalysis && analysis.handednessAnalysis.advantage > 10) {
      justificationParts.push(analysis.handednessAnalysis.description);
    }
    
    // Add first pitch advantage if relevant
    if (this.customBatters.has(batterName)) {
      const batterData = this.customBatters.get(batterName);
      if (batterData.zSwingPercent > 35 && this.pitcherArsenal.has(pitcherName)) {
        const arsenalData = this.pitcherArsenal.get(pitcherName);
        const fastballData = Array.from(arsenalData.pitchTypes.values())
          .find(p => p.pitchName.toLowerCase().includes('fastball'));
        
        if (fastballData && fastballData.baAgainst > 0.280) {
          justificationParts.push('First pitch hunter advantage');
        }
      }
    }
    
    // 5. Generate final justification
    if (justificationParts.length === 0) {
      return `General matchup advantage (Exploit Score: ${analysis.exploitScore.toFixed(1)})`;
    }
    
    if (justificationParts.length === 1) {
      return justificationParts[0];
    }
    
    if (justificationParts.length === 2) {
      return `${justificationParts[0]} + ${justificationParts[1]}`;
    }
    
    // For 3+ factors, create professional multi-factor explanation
    const primaryFactors = justificationParts.slice(0, 3);
    return `${primaryFactors.join(' + ')}${justificationParts.length > 3 ? ` + ${justificationParts.length - 3} more factors` : ''}`;
  }

  /**
   * Analyze handedness matchup using 16-scenario data
   */
  analyzeHandednessMatchup(batterName, pitcherName) {
    let advantage = 0;
    let description = '';
    
    // Get handedness from data
    const batterHand = this.getBatterHandedness(batterName);
    const pitcherHand = this.getPitcherHandedness(pitcherName);
    
    if (!batterHand || !pitcherHand) {
      return { advantage: 0, description: 'Handedness data unavailable' };
    }
    
    // Traditional platoon advantage
    if ((batterHand === 'L' && pitcherHand === 'R') || (batterHand === 'R' && pitcherHand === 'L')) {
      advantage += 12;
      description = `${batterHand}HB vs ${pitcherHand}HP platoon advantage`;
    }
    
    // Check specific handedness data if available
    if (this.handednessData.has(batterName)) {
      const handednessData = this.handednessData.get(batterName);
      const matchupKey = `${batterHand}v${pitcherHand}`;
      
      if (handednessData.has(matchupKey)) {
        const matchupData = handednessData.get(matchupKey);
        
        // High pull air rate in favorable matchup
        if (matchupData.pullAirRate > 15 && advantage > 0) {
          advantage += 8;
          description += ` with high pull power (${matchupData.pullAirRate.toFixed(1)}%)`;
        }
        
        // Line drive rate advantage
        if (matchupData.ldRate > 25) {
          advantage += 5;
        }
      }
    }
    
    return { advantage, description, batterHand, pitcherHand };
  }

  /**
   * Analyze arsenal-specific matchup
   */
  analyzeArsenalMatchup(batterName, pitcherName) {
    let exploitScore = 0;
    let keyWeakness = 'Standard matchup';
    let situationalAdvantage = null;
    
    const pitcherArsenal = this.pitcherArsenal.get(pitcherName);
    const batterData = this.customBatters.get(batterName);
    
    if (!pitcherArsenal || !batterData) {
      return { exploitScore, keyWeakness, situationalAdvantage };
    }
    
    // Find pitcher's weakest pitches
    let weakestPitch = null;
    let highestBA = 0;
    
    for (const [pitchType, pitchData] of pitcherArsenal.pitchTypes) {
      if (pitchData.baAgainst > highestBA && pitchData.usage > 10) {
        highestBA = pitchData.baAgainst;
        weakestPitch = pitchData;
      }
    }
    
    if (weakestPitch && highestBA > 0.270) {
      exploitScore += 15;
      keyWeakness = `vs vulnerable ${weakestPitch.pitchName} (${(highestBA * 1000).toFixed(0)} BA against)`;
      
      // Check if batter has specific advantages against this pitch type
      if (weakestPitch.pitchName.toLowerCase().includes('fastball') && batterData.zSwingPercent > 35) {
        exploitScore += 8;
        situationalAdvantage = "Aggressive vs vulnerable fastball";
      } else if (weakestPitch.pitchName.toLowerCase().includes('slider') && batterData.whiffPercent < 20) {
        exploitScore += 10;
        situationalAdvantage = "Good contact vs ineffective slider";
      }
    }
    
    return { exploitScore, keyWeakness, situationalAdvantage };
  }

  /**
   * Analyze swing mechanics advantage
   */
  analyzeSwingMechanicsAdvantage(batterName, pitcherVulns) {
    let advantage = 0;
    let factor = '';
    let value = null;
    
    const swingData = this.swingPathData.get(batterName);
    if (!swingData) return { advantage, factor, value };
    
    const overallData = swingData.get('overall');
    if (!overallData) return { advantage, factor, value };
    
    // High attack angle vs fly ball vulnerability
    if (overallData.attackAngle > 15 && pitcherVulns.contactQualityVulnerabilities.some(v => v.type === 'barrel_vulnerability')) {
      advantage += 8;
      factor = `Optimal attack angle (${overallData.attackAngle.toFixed(1)}°) vs vulnerable pitcher`;
      value = overallData.attackAngle;
    }
    
    // Fast swing speed
    if (overallData.avgSwingSpeed > 72) {
      advantage += 4;
      factor = factor || `Elite swing speed (${overallData.avgSwingSpeed.toFixed(1)} mph)`;
      value = value || overallData.avgSwingSpeed;
    }
    
    return { advantage, factor, value };
  }

  /**
   * Rank exploiters with advanced scoring algorithm
   */
  rankExploitersWithAdvancedScoring(exploiters) {
    // Multi-tier scoring with dynamic thresholds
    return exploiters
      .filter(e => e.exploitIndex >= 45) // Lower threshold for more opportunities
      .sort((a, b) => {
        // Primary: Combined score (exploit index * confidence)
        const aCombined = a.combinedScore;
        const bCombined = b.combinedScore;
        
        if (Math.abs(aCombined - bCombined) > 3) {
          return bCombined - aCombined;
        }
        
        // Secondary: Data quality
        const qualityOrder = { 'excellent': 4, 'good': 3, 'fair': 2, 'limited': 1 };
        const aQuality = qualityOrder[a.dataQuality] || 1;
        const bQuality = qualityOrder[b.dataQuality] || 1;
        
        if (aQuality !== bQuality) {
          return bQuality - aQuality;
        }
        
        // Tertiary: Number of situational advantages
        return (b.situationalAdvantages?.length || 0) - (a.situationalAdvantages?.length || 0);
      })
      .slice(0, 25); // Top 25 exploiters
  }

  /**
   * Load starting lineups
   */
  async loadStartingLineups(date) {
    try {
      // Try date-specific file first
      let response;
      try {
        response = await fetch(`/data/lineups/starting_lineups_${date}.json`);
        if (!response.ok) throw new Error('Date-specific file not found');
      } catch {
        // Fallback to generic file
        response = await fetch('/data/starting_lineups.json');
        if (!response.ok) throw new Error('Generic file not found');
      }
      
      const lineupData = await response.json();
      
      // Validate data structure
      if (!lineupData.games || !Array.isArray(lineupData.games)) {
        throw new Error('Invalid lineup data structure');
      }
      
      return lineupData;
    } catch (error) {
      console.warn('Failed to load starting lineups:', error);
      return null;
    }
  }

  /**
   * Get team hitters from recent game data
   */
  async getTeamHitters(teamAbbr, date) {
    try {
      // Look for recent game data
      const gameDate = new Date(date);
      
      for (let i = 0; i < 7; i++) {
        const checkDate = new Date(gameDate);
        checkDate.setDate(checkDate.getDate() - i);
        
        const year = checkDate.getFullYear();
        const month = checkDate.toLocaleLString('en-US', { month: 'long' }).toLowerCase();
        const day = checkDate.getDate();
        
        try {
          const response = await fetch(`/data/${year}/${month}/${month}_${day.toString().padStart(2, '0')}_${year}.json`);
          if (response.ok) {
            const gameData = await response.json();
            
            if (gameData.players && Array.isArray(gameData.players)) {
              const teamHitters = gameData.players
                .filter(p => 
                  p.playerType === 'hitter' &&
                  (p.team === teamAbbr || p.Team === teamAbbr) &&
                  p.name &&
                  (p.AB > 0 || p.H > 0)
                )
                .map(p => ({
                  name: p.name,
                  team: teamAbbr,
                  stats: {
                    AB: p.AB || 0,
                    H: p.H || 0,
                    HR: p.HR || 0,
                    RBI: p.RBI || 0,
                    AVG: p.AVG || 0
                  }
                }))
                .slice(0, 9); // Top 9 hitters
              
              if (teamHitters.length >= 6) {
                console.log(`   📊 Found ${teamHitters.length} hitters for ${teamAbbr}`);
                return teamHitters;
              }
            }
          }
        } catch (error) {
          continue;
        }
      }
      
      console.warn(`   ⚠️ No recent hitters found for team ${teamAbbr}`);
      return [];
    } catch (error) {
      console.warn(`Error getting team hitters for ${teamAbbr}:`, error);
      return [];
    }
  }

  /**
   * Get batter handedness
   */
  getBatterHandedness(batterName) {
    const normalizedName = this.normalizeName(batterName);
    
    // Check handedness data for evidence
    if (this.handednessData.has(normalizedName)) {
      const handednessData = this.handednessData.get(normalizedName);
      if (handednessData.has('LvL') || handednessData.has('LvR')) {
        return 'L';
      } else if (handednessData.has('RvL') || handednessData.has('RvR')) {
        return 'R';
      }
    }
    
    return 'R'; // Default assumption
  }

  /**
   * Get pitcher handedness
   */
  getPitcherHandedness(pitcherName) {
    const normalizedName = this.normalizeName(pitcherName);
    
    if (this.customPitchers.has(normalizedName)) {
      const pitcherData = this.customPitchers.get(normalizedName);
      return pitcherData.pitchHand || 'R';
    }
    
    return 'R'; // Default assumption
  }

  /**
   * Assess data quality based on sample size
   */
  assessDataQuality(sampleSize, playerType) {
    if (playerType === 'hitter') {
      if (sampleSize >= 250) return 'excellent';
      if (sampleSize >= 150) return 'good';
      if (sampleSize >= 75) return 'fair';
      return 'limited';
    } else { // pitcher
      if (sampleSize >= 200) return 'excellent';
      if (sampleSize >= 100) return 'good';
      if (sampleSize >= 50) return 'fair';
      return 'limited';
    }
  }

  /**
   * Normalize player names for consistent matching
   */
  normalizeName(name) {
    if (!name) return '';
    
    // Handle "Last, First" format
    if (name.includes(',')) {
      const parts = name.split(',');
      if (parts.length === 2) {
        const last = parts[0].trim();
        const first = parts[1].trim();
        name = `${first} ${last}`;
      }
    }
    
    // Clean up the name
    name = name.replace(/[^\w\s\.]/g, '');
    name = name.replace(/\s+/g, ' ');
    
    return name.trim();
  }

  /**
   * Get data sources summary
   */
  getDataSourcesSummary() {
    return [
      `hitter_exit_velocity_2025.csv - ${this.hitterExitVelocity.size} hitters with contact quality`,
      `pitcher_exit_velocity_2025.csv - ${this.pitcherExitVelocity.size} pitchers with contact allowed`,
      `custom_batter_2025.csv - ${this.customBatters.size} batters with expected stats`,
      `custom_pitcher_2025.csv - ${this.customPitchers.size} pitchers with expected stats`,
      `pitcherpitcharsenalstats_2025.csv - ${this.pitcherArsenal.size} pitcher arsenals`,
      `batters-batted-ball-*-handedness-2025.csv - ${this.handednessData.size} handedness profiles`,
      `batters-swing-path-*.csv - ${this.swingPathData.size} swing mechanics profiles`,
      `bat-tracking-swing-path-*.csv - ${this.batTrackingData.size} bat tracking profiles`
    ];
  }

  /**
   * Calculate quality metrics
   */
  calculateQualityMetrics(exploiters) {
    if (exploiters.length === 0) {
      return {
        totalExploiters: 0,
        averageConfidence: 0,
        averageExploitIndex: 0,
        averageCombinedScore: 0,
        eliteOpportunities: 0,
        highConfidenceCount: 0,
        regressionOpportunities: 0,
        contactQualityExploits: 0
      };
    }
    
    return {
      totalExploiters: exploiters.length,
      averageConfidence: Math.round((exploiters.reduce((sum, e) => sum + e.confidence, 0) / exploiters.length) * 1000) / 1000,
      averageExploitIndex: Math.round((exploiters.reduce((sum, e) => sum + e.exploitIndex, 0) / exploiters.length) * 10) / 10,
      averageCombinedScore: Math.round((exploiters.reduce((sum, e) => sum + e.combinedScore, 0) / exploiters.length) * 10) / 10,
      eliteOpportunities: exploiters.filter(e => e.batterClassification === 'elite_opportunity').length,
      strongOpportunities: exploiters.filter(e => e.batterClassification === 'strong_opportunity').length,
      highConfidenceCount: exploiters.filter(e => e.confidence >= 0.75).length,
      regressionOpportunities: exploiters.filter(e => e.regressionOpportunity).length,
      contactQualityExploits: exploiters.filter(e => e.contactQualityEdge).length,
      situationalAdvantages: exploiters.filter(e => e.situationalAdvantages && e.situationalAdvantages.length > 0).length
    };
  }

  /**
   * Get empty result structure
   */
  getEmptyResult(reason) {
    return {
      exploiters: [],
      totalAnalyzed: 0,
      gamesAnalyzed: 0,
      confidence: 0,
      error: reason,
      lastUpdated: new Date().toISOString()
    };
  }
}

const enhancedWeakspotExploiterService = new EnhancedWeakspotExploiterService();
export default enhancedWeakspotExploiterService;
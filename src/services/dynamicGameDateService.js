/**
 * Dynamic Game Date Discovery Service - Browser Compatible
 * 
 * Discovers actual game dates using a pre-built file list to avoid HTTP 404 errors.
 * This approach handles postponements, doubleheaders, and schedule changes
 * automatically by using only files that actually exist.
 * 
 * Algorithm:
 * 1. Load available files list (generated by generate_file_list.sh)
 * 2. Filter files from current date backward
 * 3. Check each file for actual game data (players)
 * 4. Return all dates with player data (complete season coverage)
 */

class DynamicGameDateService {
  constructor() {
    this.currentYear = new Date().getFullYear();
    this.cache = new Map();
    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
    this.availableFiles = null;
    this.filesLoaded = false;
  }

  /**
   * Load available files list (generated by generate_file_list.sh)
   */
  async loadAvailableFiles() {
    if (this.filesLoaded && this.availableFiles) {
      return this.availableFiles;
    }
    
    try {
      const response = await fetch('/data/available_files.json');
      if (!response.ok) {
        console.warn('üìã Available files list not found - run ./generate_file_list.sh');
        return null;
      }
      
      const data = await response.json();
      this.availableFiles = data;
      this.filesLoaded = true;
      
      console.log(`üìã Loaded ${data.totalFiles} available files (generated: ${data.generated})`);
      return data;
    } catch (error) {
      console.error('‚ùå Error loading available files:', error);
      return null;
    }
  }

  /**
   * Check if a specific file has game data by fetching it
   */
  async hasGameData(filePath) {
    try {
      const url = `/${filePath}`;
      const response = await fetch(url);
      if (!response.ok) {
        return false; // File doesn't exist
      }
      
      const gameData = await response.json();
      
      // Check if there are actual players (indicating games were played)
      return gameData.players && Array.isArray(gameData.players) && gameData.players.length > 0;
    } catch {
      return false;
    }
  }

  /**
   * Get all actual game dates using the available files list (COMPLETE SEASON COVERAGE)
   */
  async discoverGameDates(currentDate, options = {}) {
    const {
      maxDaysBack = 365, // Default to full season
      useCache = true
    } = options;

    const cacheKey = `${currentDate}_${maxDaysBack}`;
    
    // Check cache first
    if (useCache && this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      if (Date.now() - cached.timestamp < this.cacheTimeout) {
        console.log(`üìÖ Using cached game dates: ${cached.dates.length} dates`);
        return cached.dates;
      }
    }

    try {
      // Load available files list
      const filesList = await this.loadAvailableFiles();
      if (!filesList) {
        console.warn('‚ö†Ô∏è No files list available - falling back to date range method');
        return this.generateFallbackDateRange(currentDate, maxDaysBack);
      }

      const current = new Date(currentDate);
      const cutoffDate = new Date(current.getTime() - (maxDaysBack * 24 * 60 * 60 * 1000));
      
      console.log(`üîç Discovering game dates from ${filesList.totalFiles} available files...`);
      console.log(`üìÖ Date range: ${currentDate} back ${maxDaysBack} days to ${cutoffDate.toISOString().split('T')[0]}`);

      // Filter files within our date range, going backward from current date
      const relevantFiles = filesList.files
        .filter(file => {
          const fileDate = new Date(file.date);
          return fileDate <= current && fileDate >= cutoffDate;
        })
        .sort((a, b) => new Date(b.date) - new Date(a.date)); // Sort newest first

      console.log(`üîç Found ${relevantFiles.length} files in date range - checking for player data...`);

      const gameDates = [];
      let processedCount = 0;
      
      // Process files in batches to avoid overwhelming the browser
      const batchSize = 8; // Reasonable batch size
      
      for (let i = 0; i < relevantFiles.length; i += batchSize) {
        const batch = relevantFiles.slice(i, i + batchSize);
        
        // Process batch with staggered timing
        const batchPromises = batch.map(async (file, index) => {
          // Small delay to prevent request overwhelming
          if (index > 0) {
            await new Promise(resolve => setTimeout(resolve, index * 5));
          }
          
          processedCount++;
          
          try {
            const hasData = await this.hasGameData(file.path);
            if (hasData) {
              return file.date;
            }
          } catch (error) {
            // Continue with other files - some might be corrupted or empty
          }
          return null;
        });

        const batchResults = await Promise.all(batchPromises);
        
        // Add successful dates to our list
        batchResults.forEach(dateStr => {
          if (dateStr) {
            gameDates.push(dateStr);
          }
        });

        // Progress update and yield to browser
        if (processedCount % 20 === 0) {
          console.log(`üîç Processed ${processedCount}/${relevantFiles.length} files... (${gameDates.length} with player data)`);
          // Yield to browser to prevent blocking
          await new Promise(resolve => setTimeout(resolve, 5));
        }
      }

      // Sort chronologically (oldest first)
      gameDates.sort();

      console.log(`‚úÖ COMPLETE DISCOVERY: Found ${gameDates.length} actual game dates from ${relevantFiles.length} available files`);
      if (gameDates.length > 0) {
        console.log(`üìÖ Full season range: ${gameDates[0]} to ${gameDates[gameDates.length - 1]}`);
      }

      // Cache the result
      if (useCache) {
        this.cache.set(cacheKey, {
          dates: gameDates,
          timestamp: Date.now()
        });
      }

      return gameDates;
    } catch (error) {
      console.error('‚ùå Error discovering game dates:', error);
      return [];
    }
  }

  /**
   * Get recent game dates (last N actual games)
   */
  async getRecentGameDates(currentDate, count = 30) {
    try {
      const allGameDates = await this.discoverGameDates(currentDate, {
        maxDaysBack: count * 2, // Get extra to ensure we have enough actual games
        useCache: true
      });

      // Return the most recent N game dates
      return allGameDates.slice(-count);
    } catch (error) {
      console.error('‚ùå Error getting recent game dates:', error);
      return [];
    }
  }

  /**
   * Get statistics about discovered data
   */
  async getDataStats(currentDate) {
    try {
      const gameDates = await this.discoverGameDates(currentDate, { maxDaysBack: 180 });
      
      const stats = {
        totalGameDates: gameDates.length,
        firstGameDate: gameDates[0] || null,
        lastGameDate: gameDates[gameDates.length - 1] || null,
        monthlyBreakdown: {}
      };

      // Calculate monthly breakdown
      for (const dateStr of gameDates) {
        const date = new Date(dateStr);
        const monthKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
        stats.monthlyBreakdown[monthKey] = (stats.monthlyBreakdown[monthKey] || 0) + 1;
      }

      return stats;
    } catch (error) {
      console.error('‚ùå Error getting data stats:', error);
      return {
        totalGameDates: 0,
        firstGameDate: null,
        lastGameDate: null,
        monthlyBreakdown: {}
      };
    }
  }

  /**
   * Clear cache
   */
  clearCache() {
    this.cache.clear();
    console.log('üóëÔ∏è Dynamic game date cache cleared');
  }

  /**
   * Generate fallback date range (for when file discovery fails)
   */
  generateFallbackDateRange(currentDate, daysBefore = 365) {
    const dates = [];
    const current = new Date(currentDate);
    
    for (let i = daysBefore; i >= 0; i--) {
      const date = new Date(current);
      date.setDate(current.getDate() - i);
      dates.push(date.toISOString().split('T')[0]);
    }
    
    console.log(`üìÖ Generated fallback date range: ${dates.length} dates`);
    return dates;
  }

  /**
   * Main method for pitcher cards - discover ALL actual game dates with complete coverage
   */
  async getGameDatesForAnalysis(currentDate, options = {}) {
    // Default to full season coverage - no arbitrary limits
    const { maxDaysBack = 365 } = options;

    try {
      // Use file-based discovery for complete season coverage
      const discoveredDates = await this.discoverGameDates(currentDate, { maxDaysBack });
      
      if (discoveredDates && discoveredDates.length > 0) {
        console.log(`‚úÖ COMPLETE ANALYSIS: Using ${discoveredDates.length} actual game dates (full season coverage)`);
        return discoveredDates;
      }

      // Fallback to date range if discovery fails
      console.warn('‚ö†Ô∏è File discovery returned no dates - falling back to date range');
      return this.generateFallbackDateRange(currentDate, maxDaysBack);
    } catch (error) {
      console.error('‚ùå Error in dynamic game date discovery:', error);
      console.log('üîÑ Using fallback date range method');
      return this.generateFallbackDateRange(currentDate, maxDaysBack);
    }
  }
}

// Create singleton instance
const dynamicGameDateService = new DynamicGameDateService();

export default dynamicGameDateService;
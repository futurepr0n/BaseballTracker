/**
 * Rolling Stats Service
 * 
 * Loads accurate player statistics from the rolling_stats files
 * which are generated by generate_rolling_stats.sh and contain
 * properly aggregated season and recent performance data.
 */

/**
 * Load rolling stats data from file
 */
const loadRollingStatsData = async (dateStr, timeframe = 'season') => {
  try {
    // Try to load the specific date file first, then fall back to latest
    const urls = [
      `/data/rolling_stats/rolling_stats_${timeframe}_${dateStr}.json`,
      `/data/rolling_stats/rolling_stats_${timeframe}_latest.json`
    ];
    
    for (const url of urls) {
      try {
        const response = await fetch(url);
        if (response.ok) {
          const data = await response.json();
          console.log(`‚úÖ Loaded rolling stats from ${url}`);
          return data;
        }
      } catch (error) {
        console.log(`Failed to load ${url}, trying next...`);
      }
    }
    
    console.error(`‚ùå Could not load rolling stats for ${timeframe} timeframe`);
    return null;
  } catch (error) {
    console.error('Error loading rolling stats:', error);
    return null;
  }
};

/**
 * Find player in rolling stats data by name and team
 * CRITICAL: Merge data from multiple sections (allHitters + allHRLeaders + others)
 */
const findPlayerInRollingStats = (rollingData, playerName, playerTeam) => {
  if (!rollingData) return null;
  
  let playerStats = {};
  
  // 1. Start with allHitters section (has H, AB, R, RBI, AVG but NO HR)
  if (rollingData.allHitters) {
    const hitterData = rollingData.allHitters.find(p => 
      p.name === playerName && p.team === playerTeam
    );
    if (hitterData) {
      console.log(`üéØ Found ${playerName} in allHitters`);
      playerStats = { ...hitterData };
    }
  }
  
  // 2. Merge HR data from allHRLeaders (has HR, hrsPerGame)
  if (rollingData.allHRLeaders) {
    const hrData = rollingData.allHRLeaders.find(p => 
      p.name === playerName && p.team === playerTeam
    );
    if (hrData) {
      console.log(`üéØ Found ${playerName} in allHRLeaders with ${hrData.HR} HRs`);
      playerStats.HR = hrData.HR;
      playerStats.hrsPerGame = hrData.hrsPerGame;
      playerStats.hrRate = hrData.rate;
    }
  }
  
  // 3. Check for additional stats in playerPerformance section
  if (rollingData.playerPerformance) {
    const perfData = rollingData.playerPerformance.find(p => 
      p.name === playerName && p.team === playerTeam
    );
    if (perfData) {
      console.log(`üéØ Found ${playerName} in playerPerformance`);
      // Merge any additional fields
      playerStats = { ...playerStats, ...perfData };
    }
  }
  
  // 4. Look for stolen bases in allSBLeaders
  if (rollingData.allSBLeaders) {
    const sbData = rollingData.allSBLeaders.find(p => 
      p.name === playerName && p.team === playerTeam
    );
    if (sbData) {
      console.log(`üéØ Found ${playerName} in allSBLeaders with ${sbData.SB} SBs`);
      playerStats.SB = sbData.SB;
    }
  }
  
  // 5. Check hittersByTeam for any missing data
  if (!playerStats.name && rollingData.hittersByTeam && rollingData.hittersByTeam[playerTeam]) {
    const teamData = rollingData.hittersByTeam[playerTeam].find(p => 
      p.name === playerName
    );
    if (teamData) {
      console.log(`üéØ Found ${playerName} in hittersByTeam`);
      playerStats = { ...teamData, ...playerStats }; // Preserve already found data
    }
  }
  
  // 6. Final fallback to topHitters
  if (!playerStats.name && rollingData.topHitters) {
    const topData = rollingData.topHitters.find(p => 
      p.name === playerName && p.team === playerTeam
    );
    if (topData) {
      console.log(`üéØ Found ${playerName} in topHitters`);
      playerStats = { ...topData, ...playerStats };
    }
  }
  
  if (playerStats.name) {
    console.log(`‚úÖ Merged stats for ${playerName}:`, {
      H: playerStats.H,
      HR: playerStats.HR || 0,
      RBI: playerStats.RBI,
      AVG: playerStats.avg || playerStats.battingAvg,
      games: playerStats.games
    });
    return playerStats;
  }
  
  console.log(`‚ùå Could not find ${playerName} (${playerTeam}) in any section of rolling stats`);
  return null;
};

/**
 * Get comprehensive player stats from rolling stats
 */
export const getPlayerRollingStats = async (playerName, playerTeam, currentDate) => {
  try {
    const dateStr = currentDate instanceof Date 
      ? currentDate.toISOString().split('T')[0]
      : currentDate;
    
    console.log(`üìä Loading rolling stats for ${playerName} (${playerTeam})`);
    
    // Load season, last 30, and last 7 stats in parallel
    const [seasonData, last30Data, last7Data] = await Promise.all([
      loadRollingStatsData(dateStr, 'season'),
      loadRollingStatsData(dateStr, 'last_30'),
      loadRollingStatsData(dateStr, 'last_7')
    ]);
    
    // Find player in each dataset
    const seasonStats = findPlayerInRollingStats(seasonData, playerName, playerTeam);
    const last30Stats = findPlayerInRollingStats(last30Data, playerName, playerTeam);
    const last7Stats = findPlayerInRollingStats(last7Data, playerName, playerTeam);
    
    if (!seasonStats) {
      console.error(`‚ùå No season stats found for ${playerName} in rolling data`);
      return null;
    }
    
    console.log(`‚úÖ Found rolling stats for ${playerName}:`, {
      season: !!seasonStats,
      last30: !!last30Stats,
      last7: !!last7Stats
    });
    
    return {
      season: seasonStats,
      last30: last30Stats,
      last7: last7Stats,
      lastUpdated: seasonData?.generatedAt
    };
    
  } catch (error) {
    console.error('Error getting player rolling stats:', error);
    return null;
  }
};

/**
 * Get team performance from rolling stats
 */
export const getTeamRollingStats = async (teamAbbr, currentDate) => {
  try {
    const dateStr = currentDate instanceof Date 
      ? currentDate.toISOString().split('T')[0]
      : currentDate;
    
    console.log(`üèüÔ∏è Loading comprehensive team stats for ${teamAbbr}`);
    
    const seasonData = await loadRollingStatsData(dateStr, 'season');
    if (!seasonData) {
      console.error(`‚ùå No rolling stats data available`);
      return null;
    }
    
    // Collect all players from this team across all sections
    const teamPlayersMap = new Map();
    
    // Get complete player data from allHitters (has AB, R, RBI)
    if (seasonData.allHitters) {
      seasonData.allHitters
        .filter(p => p.team === teamAbbr)
        .forEach(player => {
          const key = player.name;
          teamPlayersMap.set(key, { ...player });
        });
    }
    
    // Merge HR data from allHRLeaders
    if (seasonData.allHRLeaders) {
      seasonData.allHRLeaders
        .filter(p => p.team === teamAbbr)
        .forEach(player => {
          const existing = teamPlayersMap.get(player.name) || {};
          teamPlayersMap.set(player.name, {
            ...existing,
            ...player,
            HR: player.HR
          });
        });
    }
    
    // Convert to array
    const teamPlayers = Array.from(teamPlayersMap.values());
    
    if (teamPlayers.length === 0) {
      console.error(`‚ùå No players found for team ${teamAbbr}`);
      return null;
    }
    
    console.log(`üèüÔ∏è Found ${teamPlayers.length} players for ${teamAbbr}`);
    
    // Calculate team aggregates with actual stats
    const teamStats = {
      players: teamPlayers,
      totalHits: teamPlayers.reduce((sum, p) => sum + (p.H || 0), 0),
      totalAB: teamPlayers.reduce((sum, p) => sum + (p.AB || 0), 0),
      totalRuns: teamPlayers.reduce((sum, p) => sum + (p.R || 0), 0),
      totalHR: teamPlayers.reduce((sum, p) => sum + (p.HR || 0), 0),
      totalRBI: teamPlayers.reduce((sum, p) => sum + (p.RBI || 0), 0),
      totalGames: Math.max(...teamPlayers.map(p => p.games || 0))
    };
    
    // Calculate team averages
    teamStats.teamBA = teamStats.totalAB > 0 ? 
      (teamStats.totalHits / teamStats.totalAB).toFixed(3) : '.000';
    teamStats.runsPerGame = teamStats.totalGames > 0 ?
      (teamStats.totalRuns / teamStats.totalGames).toFixed(1) : '0.0';
    teamStats.hrPerGame = teamStats.totalGames > 0 ?
      (teamStats.totalHR / teamStats.totalGames).toFixed(1) : '0.0';
    
    // Calculate simple OPS estimate
    const teamOBP = teamStats.totalAB > 0 ? 
      (teamStats.totalHits / teamStats.totalAB) : 0; // Simplified OBP
    const teamSLG = teamStats.totalAB > 0 ?
      ((teamStats.totalHits + teamStats.totalHR * 3) / teamStats.totalAB) : 0; // Simplified SLG
    teamStats.teamOPS = (teamOBP + teamSLG).toFixed(3);
    
    console.log(`üèüÔ∏è Team ${teamAbbr} stats:`, {
      BA: teamStats.teamBA,
      runsPerGame: teamStats.runsPerGame,
      totalHR: teamStats.totalHR,
      totalRuns: teamStats.totalRuns,
      players: teamPlayers.length
    });
    
    return teamStats;
    
  } catch (error) {
    console.error('Error getting team rolling stats:', error);
    return null;
  }
};

/**
 * Get last game date for a player (most recent data point)
 */
export const getPlayerLastSeen = async (playerName, playerTeam, currentDate) => {
  try {
    const dateStr = currentDate instanceof Date 
      ? currentDate.toISOString().split('T')[0]
      : currentDate;
    
    // Check recent rolling stats for last activity
    const currentData = await loadRollingStatsData(dateStr, 'current');
    if (currentData) {
      const playerStats = findPlayerInRollingStats(currentData, playerName, playerTeam);
      if (playerStats && playerStats.lastGameDate) {
        return playerStats.lastGameDate;
      }
    }
    
    // Fallback to current date if no specific last game date
    return dateStr;
    
  } catch (error) {
    console.error('Error getting player last seen:', error);
    return currentDate;
  }
};

/**
 * Get previous season (2024) stats from roster.json
 */
export const getPlayer2024Stats = async (playerName, playerTeam) => {
  try {
    console.log(`üìä Loading 2024 stats for ${playerName} from roster.json`);
    
    const response = await fetch('/data/rosters.json');
    if (!response.ok) {
      throw new Error('Could not load roster data');
    }
    
    const rosterData = await response.json();
    
    // Find player in roster (exact match on abbreviated name)
    const player = rosterData.find(p => 
      p.name === playerName && p.team === playerTeam
    );
    
    if (player && player.stats) {
      console.log(`‚úÖ Found 2024 stats for ${playerName}:`, player.stats);
      
      // Convert 2024_X format to cleaner format
      return {
        games: player.stats['2024_Games'] || 0,
        AB: player.stats['2024_AB'] || 0,
        R: player.stats['2024_R'] || 0,
        H: player.stats['2024_H'] || 0,
        doubles: player.stats['2024_2B'] || 0,
        triples: player.stats['2024_3B'] || 0,
        HR: player.stats['2024_HR'] || 0,
        SB: player.stats['2024_SB'] || 0,
        BB: player.stats['2024_BB'] || 0,
        SO: player.stats['2024_SO'] || 0,
        AVG: player.stats['2024_AVG'] || 0,
        SLG: player.stats['2024_SLG'] || 0,
        OBP: player.stats['2024_OBP'] || 0,
        OPS: player.stats['2024_OPS'] || 0,
        fullName: player.fullName,
        bats: player.bats
      };
    }
    
    console.log(`‚ùå No 2024 stats found for ${playerName} in roster.json`);
    return null;
    
  } catch (error) {
    console.error('Error loading 2024 stats:', error);
    return null;
  }
};
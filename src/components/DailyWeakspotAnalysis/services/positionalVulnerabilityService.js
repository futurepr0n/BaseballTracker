// Positional Vulnerability Service - Enhanced integration for Best Bets analysis

class PositionalVulnerabilityService {
  constructor() {
    this.cache = new Map();
    this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
  }

  /**
   * Extract and enhance positional vulnerabilities from comprehensive analysis
   * @param {Object} comprehensiveAnalysis - Analysis data from DailyWeakspotAnalysis
   * @returns {Array} Enhanced position vulnerability data
   */
  extractPositionVulnerabilities(comprehensiveAnalysis) {
    if (!comprehensiveAnalysis) return [];

    const vulnerabilities = [];

    // Process each pitcher's analysis
    const processPitcherAnalysis = (pitcherAnalysis, pitcherName, opposingTeam) => {
      if (!pitcherAnalysis?.position_vulnerabilities) return;

      Object.entries(pitcherAnalysis.position_vulnerabilities).forEach(([positionKey, data]) => {
        const positionNumber = parseInt(positionKey.replace('position_', ''));
        
        if (!isNaN(positionNumber) && data.vulnerability_score > 8) { // Threshold for meaningful vulnerabilities
          vulnerabilities.push({
            pitcher: pitcherName,
            opposingTeam: opposingTeam,
            position: positionNumber,
            positionDescription: this.getPositionDescription(positionNumber),
            vulnerabilityScore: data.vulnerability_score || 0,
            hrRate: data.hr_rate || 0,
            hitRate: data.hit_rate || 0,
            sampleSize: data.sample_size || 0,
            confidenceScore: Math.min(data.vulnerability_score * 8, 100), // Scale to 0-100
            strategicValue: this.getStrategicValue(positionNumber, data.vulnerability_score),
            effectiveness: data.hr_rate > 0.05 ? 'hr_vulnerable' : 'hit_vulnerable',
            riskLevel: this.assessRiskLevel(data.vulnerability_score, data.sample_size)
          });
        }
      });
    };

    // Handle different analysis structures
    if (comprehensiveAnalysis.matchup_analysis) {
      // Multiple matchup format
      Object.values(comprehensiveAnalysis.matchup_analysis).forEach(matchup => {
        if (matchup.away_pitcher_analysis) {
          processPitcherAnalysis(
            matchup.away_pitcher_analysis,
            matchup.away_pitcher_analysis.pitcher_name,
            matchup.matchup?.home_team || 'Unknown'
          );
        }
        if (matchup.home_pitcher_analysis) {
          processPitcherAnalysis(
            matchup.home_pitcher_analysis,
            matchup.home_pitcher_analysis.pitcher_name,
            matchup.matchup?.away_team || 'Unknown'
          );
        }
      });
    } else {
      // Direct pitcher analysis format
      if (comprehensiveAnalysis.away_pitcher_analysis) {
        processPitcherAnalysis(
          comprehensiveAnalysis.away_pitcher_analysis,
          comprehensiveAnalysis.away_pitcher_analysis.pitcher_name,
          'Home Team' // Could be enhanced with actual team name
        );
      }
      if (comprehensiveAnalysis.home_pitcher_analysis) {
        processPitcherAnalysis(
          comprehensiveAnalysis.home_pitcher_analysis,
          comprehensiveAnalysis.home_pitcher_analysis.pitcher_name,
          'Away Team'
        );
      }
    }

    return vulnerabilities.sort((a, b) => b.vulnerabilityScore - a.vulnerabilityScore);
  }

  /**
   * Match batter opportunities with positional vulnerabilities
   * @param {Array} batterOpportunities - Batter opportunities from BaseballAPI
   * @param {Array} positionVulnerabilities - Position vulnerability data
   * @returns {Array} Enhanced opportunities with position context
   */
  enhanceOpportunitiesWithPositionData(batterOpportunities, positionVulnerabilities) {
    if (!batterOpportunities?.length || !positionVulnerabilities?.length) {
      return batterOpportunities || [];
    }

    return batterOpportunities.map(opportunity => {
      // Find matching position vulnerabilities for this pitcher
      const matchingVulnerabilities = positionVulnerabilities.filter(vuln => 
        vuln.pitcher === opportunity.pitcher
      );

      // Find the vulnerability for this player's batting position
      const playerPosition = opportunity.batting_position || opportunity.lineup_position;
      const positionVulnerability = matchingVulnerabilities.find(vuln => 
        vuln.position === playerPosition
      );

      // Calculate enhanced scores with position context
      const positionBonus = positionVulnerability ? 
        this.calculatePositionBonus(positionVulnerability) : 0;

      const enhancedOpportunity = {
        ...opportunity,
        // Enhanced scoring
        position_vulnerability_score: positionVulnerability?.vulnerabilityScore || 0,
        position_bonus: positionBonus,
        enhanced_hr_score: (opportunity.hr_score || 0) + positionBonus,
        enhanced_confidence: Math.min(
          (opportunity.confidence || 50) + (positionBonus * 0.5), 
          95
        ),
        
        // Position context
        position_context: positionVulnerability ? {
          vulnerabilityScore: positionVulnerability.vulnerabilityScore,
          positionDescription: positionVulnerability.positionDescription,
          hrRate: positionVulnerability.hrRate,
          hitRate: positionVulnerability.hitRate,
          strategicValue: positionVulnerability.strategicValue,
          effectiveness: positionVulnerability.effectiveness,
          riskLevel: positionVulnerability.riskLevel,
          sampleSize: positionVulnerability.sampleSize
        } : null,

        // All matching vulnerabilities for this pitcher
        pitcher_vulnerabilities: matchingVulnerabilities,
        vulnerability_count: matchingVulnerabilities.length,
        max_vulnerability_score: Math.max(...matchingVulnerabilities.map(v => v.vulnerabilityScore), 0)
      };

      return enhancedOpportunity;
    });
  }

  /**
   * Calculate position bonus based on vulnerability strength
   */
  calculatePositionBonus(positionVulnerability) {
    const baseScore = positionVulnerability.vulnerabilityScore;
    const sampleSize = positionVulnerability.sampleSize;
    const hrRate = positionVulnerability.hrRate;

    let bonus = 0;

    // Base vulnerability bonus (0-15 points)
    if (baseScore >= 25) bonus += 15;
    else if (baseScore >= 20) bonus += 12;
    else if (baseScore >= 15) bonus += 8;
    else if (baseScore >= 10) bonus += 5;

    // HR rate bonus (0-10 points)
    if (hrRate >= 0.08) bonus += 10;
    else if (hrRate >= 0.05) bonus += 6;
    else if (hrRate >= 0.03) bonus += 3;

    // Sample size confidence (0-5 points)
    if (sampleSize >= 50) bonus += 5;
    else if (sampleSize >= 25) bonus += 3;
    else if (sampleSize >= 10) bonus += 1;

    return Math.min(bonus, 25); // Cap at 25 point bonus
  }

  /**
   * Generate position-aware reasoning for opportunities
   */
  generatePositionReasoning(opportunity) {
    const positionContext = opportunity.position_context;
    if (!positionContext) {
      return `${opportunity.player_name} shows standard opportunity against ${opportunity.pitcher}.`;
    }

    const playerName = opportunity.player_name;
    const pitcher = opportunity.pitcher;
    const positionDesc = positionContext.positionDescription;
    const vulnScore = positionContext.vulnerabilityScore.toFixed(1);
    const hrRate = (positionContext.hrRate * 100).toFixed(1);

    let reasoning = `${playerName} (${positionDesc}) has strong positional advantage against ${pitcher}. `;
    reasoning += `Pitcher shows ${vulnScore} vulnerability score vs ${positionDesc} with ${hrRate}% HR rate. `;
    
    if (positionContext.strategicValue === 'high_value') {
      reasoning += `Premium lineup position creates high-value opportunity. `;
    }
    
    if (positionContext.effectiveness === 'hr_vulnerable') {
      reasoning += `Position particularly vulnerable to home runs. `;
    }
    
    if (positionContext.riskLevel === 'low') {
      reasoning += `Strong sample size supports confidence.`;
    } else if (positionContext.riskLevel === 'high') {
      reasoning += `Limited sample - use caution.`;
    }

    return reasoning;
  }

  /**
   * Get strategic summary of position vulnerabilities for a pitcher
   */
  getPitcherVulnerabilitySummary(pitcherName, positionVulnerabilities) {
    const pitcherVulns = positionVulnerabilities.filter(vuln => 
      vuln.pitcher === pitcherName
    );

    if (!pitcherVulns.length) return null;

    const highVulns = pitcherVulns.filter(v => v.vulnerabilityScore >= 20);
    const hrVulnerable = pitcherVulns.filter(v => v.effectiveness === 'hr_vulnerable');
    const avgScore = pitcherVulns.reduce((sum, v) => sum + v.vulnerabilityScore, 0) / pitcherVulns.length;

    return {
      pitcher: pitcherName,
      totalVulnerabilities: pitcherVulns.length,
      highVulnerabilities: highVulns.length,
      hrVulnerablePositions: hrVulnerable.length,
      averageVulnerabilityScore: avgScore.toFixed(1),
      topPositions: pitcherVulns
        .sort((a, b) => b.vulnerabilityScore - a.vulnerabilityScore)
        .slice(0, 3)
        .map(v => ({
          position: v.position,
          description: v.positionDescription,
          score: v.vulnerabilityScore.toFixed(1)
        })),
      strategicValue: this.assessPitcherStrategicValue(pitcherVulns)
    };
  }

  /**
   * Helper methods
   */
  getPositionDescription(position) {
    const positions = {
      1: 'Leadoff Hitter',
      2: '2nd Hitter', 
      3: '3rd Hitter',
      4: 'Cleanup Hitter',
      5: '5th Hitter',
      6: '6th Hitter',
      7: '7th Hitter',
      8: '8th Hitter',
      9: '9th Hitter'
    };
    return positions[position] || `${position} Position`;
  }

  getStrategicValue(position, vulnerabilityScore) {
    // Premium positions (1-5) with high vulnerability scores
    if ([1, 2, 3, 4, 5].includes(position) && vulnerabilityScore >= 20) {
      return 'high_value';
    }
    // Mid-tier positions with very high vulnerability
    if ([6, 7].includes(position) && vulnerabilityScore >= 25) {
      return 'high_value';
    }
    // Good vulnerability scores
    if (vulnerabilityScore >= 15) {
      return 'moderate_value';
    }
    return 'standard_value';
  }

  assessRiskLevel(vulnerabilityScore, sampleSize) {
    if (sampleSize >= 50 && vulnerabilityScore >= 15) return 'low';
    if (sampleSize >= 25 && vulnerabilityScore >= 10) return 'medium';
    if (sampleSize >= 10) return 'medium';
    return 'high';
  }

  assessPitcherStrategicValue(vulnerabilities) {
    const highCount = vulnerabilities.filter(v => v.vulnerabilityScore >= 20).length;
    const totalCount = vulnerabilities.length;
    
    if (highCount >= 3) return 'very_high';
    if (highCount >= 2) return 'high';
    if (totalCount >= 5) return 'moderate';
    return 'low';
  }
}

const positionalVulnerabilityService = new PositionalVulnerabilityService();
export default positionalVulnerabilityService;